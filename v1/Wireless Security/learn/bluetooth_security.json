{
    "id": "bluetooth_security",
    "topicId": "bt_security",
    "topicTitle": "Bluetooth Security",
    "description": "Explore Bluetooth vulnerabilities, from Bluejacking to modern BLE (Bluetooth Low Energy) attacks.",
    "baseKP": 100,
    "slides": [
        {
            "id": "bt_1",
            "type": "content",
            "title": "Bluetooth Overview",
            "content": "# Bluetooth Protocol ü¶∑\n\nDesigned for Personal Area Networks (PANs). Replacement for cables.\n\n## Versions\n- **Classic (BR/EDR):** High throughput (Audio streaming). Continuous connection.\n- **Low Energy (BLE):** Battery efficient (IoT, Fitness trackers). Bursty connection.\n\n## Frequency\nOperates in 2.4 GHz, hoping frequencies 1600 times/second (FHSS) to avoid interference."
        },
        {
            "id": "bt_2",
            "type": "content",
            "title": "Bluetooth Pairing",
            "content": "# Pairing & Bonding üîó\n\n**Pairing:** Establishing shared secret keys.\n**Bonding:** Storing those keys for future use.\n\n## Modes (Classic)\n- **Just Works:** No user interaction. No authentication (Susceptible to MitM!).\n- **Numeric Comparison:** Both screens show \"123456\". User confirms.\n- **Passkey Entry:** Typer \"123456\" on keyboard.\n- **Out of Band (OOB):** Exchange keys via NFC."
        },
        {
            "id": "bt_3",
            "type": "content",
            "title": "Pairing Logic Simulation",
            "content": "# Numeric Comparison üî¢\n\nSimulating the check.\n\n<!-- FULL_CODE_START\nimport random\n\ndef pairing_process():\n    print(\"--- Bluetooth Pairing (Numeric Comparison) ---\")\n    \n    # Device A generates a random nonce\n    nonce_a = random.randint(100000, 999999)\n    print(f\"Device A displays: {nonce_a}\")\n    \n    # Device B (in a secure scenario) should derive the same number\n    # In a MitM attack, the attacker might accidentally show different numbers\n    nonce_b = nonce_a # Successful case\n    print(f\"Device B displays: {nonce_b}\")\n    \n    user_input = \"yes\" # Simulating user pressing 'Pair'\n    \n    if user_input == \"yes\":\n        if nonce_a == nonce_b:\n            print(\"‚úÖ User confirmed matching codes. Keys exchanged.\")\n            return True\n        else:\n            print(\"‚ùå User saw mismatch! Attack detected?\")\n            return False\n\npairing_process()\nFULL_CODE_END -->"
        },
        {
            "id": "bt_4",
            "type": "content",
            "title": "Bluejacking",
            "content": "# Bluejacking üì®\n\nThe most basic attack.\nSending unsolicited messages (vCards/Contacts) to a discoverable device.\n\n## Impact\nLow. Ideally just harassment or social engineering (\"Add this contact: 'Support'\").\n\n## Defense\nTurn off \"Discoverable\" mode."
        },
        {
            "id": "bt_5",
            "type": "content",
            "title": "Bluesnarfing",
            "content": "# Bluesnarfing üïµÔ∏è\n\nAccessing internal data (Contacts, Messages, IMEI) without permission.\n\nThis exploits vulnerabilities in the Object Exchange (OBEX) protocol on older phones.\n\nModern smartphones are generally resistant unless the user pairs with the attacker."
        },
        {
            "id": "bt_6",
            "type": "content",
            "title": "BlueBugging",
            "content": "# BlueBugging üêõ\n\nTaking total control of the device.\n\nAllows the attacker to:\n- Make calls.\n- Listen in on calls.\n- Send SMS.\n- Connect to the internet.\n\nOriginally targeted older Nokias/Sonys. Now rare on patched iOS/Android."
        },
        {
            "id": "bt_7",
            "type": "content",
            "title": "BLE (Bluetooth Low Energy)",
            "content": "# BLE Basics üîã\n\nUsed in Smart Locks, Lightbulbs, Fitbits.\n\n## Structure\n- **GATT (Generic Attribute Profile):** Defines the data transfer.\n- **Services (UUID):** e.g., \"Heart Rate Service\".\n- **Characteristics (UUID):** e.g., \"Beats Per Minute\" value.\n\n## Weakness\nMany IoT devices implement **Zero Security**.\nThey allow *anyone* to write to the \"Unlock\" characteristic without a PIN!"
        },
        {
            "id": "bt_8",
            "type": "content",
            "title": "BLE Scanning (Demonstration)",
            "content": "# BLE Scanning üì°\n\nUsing Python `bleak` to find devices (Conceptual).\n\n```python\n# import asyncio\n# from bleak import BleakScanner\n\n# async def scan():\n#     devices = await BleakScanner.discover()\n#     for d in devices:\n#         print(f\"Found: {d.name} ({d.address})\")\n        \n# asyncio.run(scan())\n```\n\nOutput might show: `SmartLock_7A (AA:BB:CC...)`."
        },
        {
            "id": "bt_9",
            "type": "content",
            "title": "GATT Attack Scenario",
            "content": "# Smart Lock Attack üîì\n\nScenario: A cheap smart lock.\n\n1.  Hacker Scans -> Finds \"MyLock\".\n2.  Hacker Connects (No PIN required by poor design).\n3.  Hacker Enumerates Services.\n4.  Finds Characteristic `0xFF01` (Lock Control).\n5.  Writes `0x00` (Open command).\n6.  Door opens.\n\nThis is surprisingly common in cheap IoT."
        },
        {
            "id": "bt_10",
            "type": "content",
            "title": "Bluetooth Spoofing (BIAS)",
            "content": "# BIAS Attack üé≠\n\n**Bluetooth Impersonation AttackS.**\n\nExploits the fact that Secure Connections authentication is not bidirectional in some older specs.\n\nThe Master authenticates the Slave, but the Slave assumes the Master is legit. Attacker impersonates the Master (Phone) to control the Slave (Headphones/Keys)."
        },
        {
            "id": "bt_quiz_1",
            "type": "quiz",
            "title": "Attack ID",
            "content": "Identify the threat.",
            "quizQuestion": "Which attack involves sending unsolicited messages (like contact cards) to a Bluetooth device?",
            "quizOptions": [
                "Bluesnarfing",
                "Bluejacking",
                "BlueBugging",
                "Evil Twin"
            ],
            "correctOptionIndex": 1
        },
        {
            "id": "bt_11",
            "type": "content",
            "title": "BLE Sniffing",
            "content": "# Sniffing BLE üëÉ\n\nHardware: **Ubertooth One** or **nRF52 Sniffer**.\n\nSince BLE advertises on 3 channels (37, 38, 39), a sniffer listens to these.\n\nIf the pairing is \"Just Works\" or uses a static passkey, the sniffer can capture the exchange and decrypt the traffic later in Wireshark."
        },
        {
            "id": "bt_12",
            "type": "content",
            "title": "Bluetooth Enum Tool",
            "content": "# Tools: Bettercap üß¢\n\n`bettercap` is a swiss-army knife for networks.\n\n`ble.recon on` -> Starts scanning.\n`ble.enum` -> Lists services/characteristics.\n`ble.write <uuid> <value>` -> Writes data.\n\nThis allows interacting with BLE devices directly from a laptop."
        },
        {
            "id": "bt_13",
            "type": "content",
            "title": "Summary",
            "content": "# Bluetooth Summary üèÅ\n\nConvenience often shortcuts security.\n\n## Recap\n- **Classic vs BLE:** Different use cases, different flaws.\n- **Bluejacking:** Annoyance.\n- **BlueBugging:** Total control.\n- **IoT Risks:** Weak authentication in smart devices.\n\nTurn off Bluetooth when not in use!"
        }
    ]
}