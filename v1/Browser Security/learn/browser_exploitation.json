{
    "id": "learn_browser_exploitation",
    "topicId": "browser_exploitation",
    "topicTitle": "Browser Exploitation",
    "description": "Deep dive into exploiting the browser engine itself: Memory corruption, JIT bugs, and Sandbox escapes.",
    "baseKP": 100,
    "slides": [
        {
            "id": "exploit_intro_1",
            "type": "content",
            "title": "Pwning the Browser",
            "content": "# The Ultimate Target üéØ\n\nThe browser is the most complex piece of software on most computers. It parses HTML, CSS, JS, Images, Video, Audio, WebGL, and WebAssembly.\n\n**Complexity = Bugs**. \nExploiting the browser means getting Remote Code Execution (RCE) on the victim's machine just by visiting a website."
        },
        {
            "id": "drive_by_downloads_1",
            "type": "content",
            "title": "Drive-by Downloads",
            "content": "# Drive-by Downloads üöó\n\nInfection without user interaction.\n\n## Mechanism\n1.  User visits a compromised legitimate site (or malicious site).\n2.  Site loads an Exploit Kit (JS).\n3.  Kit fingerprints the browser/plugins (Flash, Java, old Chrome).\n4.  Kit fires an exploit for a known vulnerability.\n5.  Payload (Ransomware/RAT) runs silently."
        },
        {
            "id": "memory_corruption_1",
            "type": "content",
            "title": "Memory Corruption",
            "content": "# Memory Corruption üß†\n\nBrowsers are written in C++ (Chrome/V8, Firefox/Gecko, Safari/WebKit).\n\n## Bug Classes\n-   **Use-After-Free (UAF)**: Accessing memory that has been freed. The most common browser bug.\n-   **Buffer Overflow**: Writing past the end of an array.\n-   **Type Confusion**: Tricking the engine into treating an Integer as a Pointer."
        },
        {
            "id": "uaf_diagram",
            "type": "content",
            "title": "Use-After-Free Visual",
            "content": "# UAF Explained üóëÔ∏è\n\n1.  **Allocate**: `ptr = new Object()`\n2.  **Free**: `free(ptr)` (ptr is now a \"dangling pointer\")\n3.  **Replace**: `new_obj = new String(\"Payload\")` (Occupies the same memory slot)\n4.  **Use**: `ptr.execute()`\n\n**Result**: Instead of executing the original object's code, it executes the \"Payload\" we put there."
        },
        {
            "id": "jit_exploitation_1",
            "type": "content",
            "title": "JIT Exploitation",
            "content": "# Just-In-Time (JIT) Compilers ‚ö°\n\nJavaScript engines (V8, SpiderMonkey) compile JS to Machine Code at runtime for speed.\n\n## The Flaw\n-   JIT makes assumptions to optimize: \"This variable is always an Integer\".\n-   **Attack**: Break expected assumptions. If the JIT removes bounds checks because it \"proved\" they weren't needed, we can trigger a buffer overflow."
        },
        {
            "id": "v8_turbo_fan",
            "type": "content",
            "title": "V8 TurboFan",
            "content": "# Chrome's TurboFan üå™Ô∏è\n\nThe optimizing compiler in V8.\n\n## Optimization Pipeline\n1.  Ignition (interpreter) collects type feedback.\n2.  TurboFan generates optimized machine code.\n3.  **Deoptimization**: If types change, bail out to interpreter.\n\n**Exploit**: Trick TurboFan into generating wrong code that DOESN'T deoptimize when it should."
        },
        {
            "id": "heap_spray_1",
            "type": "content",
            "title": "Heap Spraying",
            "content": "# Heap Spraying üí¶\n\nA technique to facilitate exploitation.\n\n## Concept\n-   We have a code execution bug (jump to address X), but we don't know WHERE our payload is in memory.\n-   **Spray**: Fill the RAM (Heap) with millions of copies of the payload (NOP Sled + Shellcode).\n-   **Jump**: Jump to a random address (likelihood of hitting the payload is high)."
        },
        {
            "id": "spray_code",
            "type": "content",
            "title": "Heap Spray Logic",
            "content": "# JS Heap Spray üíª\n\n```javascript\nvar spray = [];\nfor (var i = 0; i < 100000; i++) {\n    // Create huge strings containing shellcode\n    spray[i] = payload + padding;\n}\n```\n\n> üõ°Ô∏è **Defense**: Architecture randomization (ASLR) and 64-bit address spaces make spraying much harder."
        },
        {
            "id": "sandbox_escape_1",
            "type": "content",
            "title": "Sandbox Escapes",
            "content": "# Escaping the Sandbox üì¶\n\nEven if you get RCE in the renderer process (the tab), you are stuck in a Sandbox.\n\n## The Sandbox\nRestricted privileges: No file access, no syscalls, isolated from OS.\n\n## The Escape\nA second exploit is needed:\n-   **Kernel Exploit**: Attack the OS kernel directly.\n-   **Broker Exploit**: Attack the Browser Broker process (privileged) via IPC (Inter-Process Communication)."
        },
        {
            "id": "exploit_chain",
            "type": "content",
            "title": "The Exploit Chain",
            "content": "# The Full Chain üîó\n\nTo pwn a modern browser, you need a chain:\n\n1.  **Info Leak**: Defeat ASLR (find addresses).\n2.  **Renderer RCE**: UAF or JIT bug to run code in the tab.\n3.  **Sandbox Escape**: Kernel or Broker bug to break out.\n\nValue: $100,000 - $500,000+ (Zerodium/Pwn2Own)."
        },
        {
            "id": "browser_exploit_quiz",
            "type": "quiz",
            "title": "Exploit Quiz",
            "content": "Check your pwn knowledge.",
            "quizQuestion": "What is the primary purpose of a 'Sandbox Escape' in browser exploitation?",
            "quizOptions": [
                "To run JavaScript faster",
                "To bypass the Same Origin Policy",
                "To elevate privileges from the restricted renderer process to the system",
                "To encrypt memory"
            ],
            "correctOptionIndex": 2
        },
        {
            "id": "mitigation_aslr_dep",
            "type": "content",
            "title": "Mitigations: ASLR & DEP",
            "content": "# OS Defenses üõ°Ô∏è\n\n-   **DEP / NX** (Data Execution Prevention): Marks memory as \"Data Only\". You can't execute code on the heap/stack. (Bypassed with ROP).\n-   **ASLR** (Address Space Layout Randomization): Randomizes locations of libraries and heap. (Bypassed with Logic/Info Leaks)."
        },
        {
            "id": "mitigation_cfi",
            "type": "content",
            "title": "Control Flow Integrity (CFI)",
            "content": "# CFI üö¶\n\nA modern defense.\n\nEnsures that the program follows the valid Control Flow Graph.\n-   Before every indirect jump/call, verify if the target is valid.\n-   Makes hijacking the instruction pointer much harder.\n-   Hard on performance, but widely deployed in Chrome/Edge."
        },
        {
            "id": "site_isolation_1",
            "type": "content",
            "title": "Site Isolation",
            "content": "# Site Isolation üèùÔ∏è\n\nChrome's defense against Spectre.\n\n## Concept\n-   Put every site (e.g., `google.com`) in its own dedicated OS Process.\n-   Even if an attacker has a memory read bug (Spectre) in their process, they can't read `bank.com`'s memory because it's physically in a different process."
        },
        {
            "id": "javascript_engines",
            "type": "content",
            "title": "Attacking Engines",
            "content": "# Target: V8 & SpiderMonkey üï∑Ô∏è\n\nSince JS engines are accessible via `script` tags, they are the primary attack surface.\n\nFuzzing these engines (Domato, Fuzzilli) generates millions of invalid JS snippets hoping to crash the engine, revealing a bug."
        },
        {
            "id": "wasm_exploitation",
            "type": "content",
            "title": "Wasm Exploitation",
            "content": "# WebAssembly Exploitation ü¶Ä\n\nWasm doesn't have standard stack canaries or ASLR *inside* its linear memory.\n\nBuffer overflows inside Wasm can overwrite Wasm data structures, potentially leading to logic bugs or control flow hijacking within the Wasm context."
        },
        {
            "id": "exploit_summary",
            "type": "content",
            "title": "Module Summary",
            "content": "# Wrap Up üéÅ\n\n-   **Memory Safety**: C++ is the root cause of most browser bugs. Rust is the future (Firefox/Servo).\n-   **JIT**: The most complex and vulnerable component.\n-   **Sandboxing**: The containment wall.\n-   **Chaining**: RCE + Escape = Pwn.\n\nBrowser exploitation is the pinnacle of binary exploitation!"
        }
    ]
}