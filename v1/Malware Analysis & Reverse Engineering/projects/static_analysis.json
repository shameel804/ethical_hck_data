[
    {
        "title": "File Hashing",
        "ques": "What is the very first step in analyzing a suspicious file? Why is creating a **File Hash** (MD5/SHA256) important?",
        "answer": {
            "type": "text",
            "content": "**Step:** Calculate the unique hash signature of the file.\n\n**Importance:** \n1. **Identification:** You can submit this hash to services like VirusTotal to see if other analysts have already seen and classified it.\n2. **Integrity:** It ensures you are working on the same file throughout the analysis and that it hasn't accidentally changed."
        },
        "explanation": "OSINT (Open Source Intelligence) saves time. Identifying known malware quickly allows for faster triage."
    },
    {
        "title": "Strings Analysis",
        "ques": "Running the `strings` command on a binary reveals readable ASCII text. What specific \"indicators of compromise\" (IOCs) are you looking for?",
        "answer": {
            "type": "text",
            "content": "**Indicators:**\n1.  **IP Addresses / Domains:** The malicious C2 server it tries to contact.\n2.  **File Paths:** Locations where it might drop payloads.\n3.  **Registry Keys:** Persistence mechanisms.\n4.  **Error Messages:** Can reveal the original project name or PDB path."
        },
        "explanation": "Strings are the low-hanging fruit of static analysis. They give immediate clues about functionality."
    },
    {
        "title": "PE File Header Analysis",
        "ques": "The **Portable Executable (PE)** header contains the compilation timestamp. How can malware authors manipulate this, and what is this technique called?",
        "answer": {
            "type": "text",
            "content": "**Technique:** **Timestomping**.\n\n**Manipulation:** Malware authors can modify the `TimeDateStamp` field in the PE header to a fake date (e.g., in the past, or a future date).\n\n**Goal:** To blend in with legitimate system files or confuse forensic timelines, making it look like the file has been on the system for years."
        },
        "explanation": "Metadata is mutable. Analysts should cross-reference header timestamps with filesystem creation dates."
    },
    {
        "title": "Analyzing Imports",
        "ques": "The **Import Address Table (IAT)** lists the DLLs and functions a program uses. If you see imports like `VirtualAlloc`, `WriteProcessMemory`, and `CreateRemoteThread`, what kind of behavior does this suggest?",
        "answer": {
            "type": "text",
            "content": "**Behavior:** **Process Injection**.\n\n**Logic:**\n1. `VirtualAlloc`: Allocate memory in another process.\n2. `WriteProcessMemory`: Write malicious code into that memory.\n3. `CreateRemoteThread`: Execute that code.\n\nThis combination strongly suggests the malware tries to hide inside another legitimate process."
        },
        "explanation": "API calls define capability. You can often predict what malware does just by reading its import list."
    },
    {
        "title": "Disassembly vs. Decompilation",
        "ques": "What is the difference between **Disassembly** and **Decompilation**?",
        "answer": {
            "type": "text",
            "content": "**Disassembly:** Translates machine code (binary) into **Assembly Language** (e.g., `MOV EAX, 1`). It is a 1-to-1 mapping and is always accurate but hard to read.\n\n**Decompilation:** Attempts to reconstruct the original high-level code (e.g., C++ or C#). It is much easier to read but is an *approximation* and can be incorrect if the code was optimized or obfuscated."
        },
        "explanation": "Decompilers guess the logic. Disassemblers show the truth."
    }
]