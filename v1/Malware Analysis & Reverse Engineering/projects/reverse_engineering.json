[
    {
        "title": "IDA Pro and Ghidra",
        "ques": "Tools like IDA Pro and Ghidra provide a **Graph View** of the disassembled code. What do the *nodes* and *edges* (arrows) in this graph typically represent?",
        "answer": {
            "type": "text",
            "content": "**Nodes:** Basic blocks of code (linear sequences of instructions with no jumps inside them).\n\n**Edges:** Control flow paths (Jumps, Branches/If statements, Loops). \n\n**Purpose:** This visualizes the control flow graph (CFG), making it much easier to understand the logic of complex functions compared to reading a flat list of assembly instructions."
        },
        "explanation": "Visualizing the structure is half the battle. Graphs show the 'shape' of the logic."
    },
    {
        "title": "Debugging Breakpoints",
        "ques": "In a debugger (like x64dbg/GDB), what happens when the execution hits a **Software Breakpoint** (INT 3 instruction)?",
        "answer": {
            "type": "text",
            "content": "**Event:** The CPU stops executing the program's code and transfers control to the **Debugger**.\n\n**Utility:** This allows the reverse engineer to pause the program at a specific moment of interest (e.g., right before a password check) to inspect the values in registers and memory stack to see the unencrypted password."
        },
        "explanation": "Dynamic analysis is interactive. Breakpoints are your ability to freeze time."
    },
    {
        "title": "Code Obfuscation",
        "ques": "What is the purpose of **Dead Code Insertion** in obfuscation? How does it affect the reverse engineer?",
        "answer": {
            "type": "text",
            "content": "**Purpose:** To bloat the code with junk instructions that have no effect on the program's outcome (e.g., `Add 0 to EAX`, `Jump to next line`).\n\n**Effect:** It confuses the analyst and decontamination tools. It makes the control flow graph look like spaghetti, wasting the analyst's time trying to understand logic that doesn't actually do anything."
        },
        "explanation": "The goal of obfuscation is not to be Unbreakable, but to be Annoying and Expensive to analyze."
    },
    {
        "title": "Packing and Entropy",
        "ques": "You have a suspicious executable. You run a tool to check its **Shannon Entropy** and it returns a score of **7.9** (out of 8.0). What does this strongly indicate?",
        "answer": {
            "type": "text",
            "content": "**Indication:** The file is likely **Packed** or **Encrypted**.\n\n**Reasoning:** Regular code and text have patterns (low entropy). Encrypted data or compressed data looks like random noise (high entropy). A score close to the maximum (8) means the file is almost purely random data, which is the hallmark of a packed payload waiting to be unpacked at runtime."
        },
        "explanation": "Entropy math detects randomness. High randomness in a code section is suspicious."
    },
    {
        "title": "Firmware Analysis (Binwalk)",
        "ques": "When analyzing an IoT device, you extract the firmware binary. What is the tool **Binwalk** used for, and how does it work?",
        "answer": {
            "type": "text",
            "content": "**Usage:** It scans the binary file looking for known file headers and signatures (magic bytes).\n\n**Function:** It can identify and automatically **extract** embedded file systems (like SquashFS, CramFS) or compressed archives (Gzip, Tar) hidden inside the single monolithic firmware blob. This allows you to get to the actual Linux file system and configuration files."
        },
        "explanation": "Binwalk is the 'unzipper' for firmware images. It finds the files within the file."
    }
]