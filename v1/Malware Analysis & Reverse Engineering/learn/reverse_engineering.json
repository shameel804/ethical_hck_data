{
    "id": "learn_reverse_engineering",
    "topicId": "reverse_engineering",
    "topicTitle": "Reverse Engineering",
    "description": "Learn the art of deconstructing software to understand its hidden logic, algorithms, and vulnerabilities.",
    "baseKP": 100,
    "slides": [
        {
            "id": "re_intro_1",
            "type": "content",
            "title": "What is Reverse Engineering? üß©",
            "content": "# Taking It Apart\n\nReverse Engineering (RE) is the process of analyzing a system to identify its components and their interrelationships.\n\n## In Software\nIt involves taking a compiled binary (e.g., `.exe`, `.apk`) and trying to recreate or understand the original source code."
        },
        {
            "id": "compilation_process",
            "type": "content",
            "title": "Compilation Process",
            "content": "# One Way Street? üõ£Ô∏è\n\n1.  **Source Code** (C++): Readable by humans.\n2.  **Compiler**: Translates to Machine Code (0s and 1s).\n3.  **Binary**: The executable file.\n\nRE tries to go backward (Binary -> Assembly -> Logic). You rarely get the exact original source code back, but you get a representation."
        },
        {
            "id": "assembly_basics",
            "type": "content",
            "title": "Assembly Language",
            "content": "# Speaking Machine ü§ñ\n\nAssembly (ASM) is a low-level language representing CPU instructions.\n\n## Common Architectures\n-   **x86 / x64**: Desktop/Server (Intel/AMD). Complex instruction set (CISC).\n-   **ARM**: Mobile/IoT (Apple M1, Android). Reduced instruction set (RISC)."
        },
        {
            "id": "cpu_registers",
            "type": "content",
            "title": "CPU Registers",
            "content": "# Registers: CPU Variables üì¶\n\nSmall, ultra-fast storage locations inside the CPU.\n\n## x64 Registers\n-   **RAX**: Accumulator (Return values).\n-   **RBX**: Base.\n-   **RCX**: Counter (Loops).\n-   **RIP**: Instruction Pointer (Where is the code running right now?).\n-   **RSP**: Stack Pointer (Top of the memory stack)."
        },
        {
            "id": "registers_quiz",
            "type": "quiz",
            "title": "Registers Quiz",
            "content": "Hardware basics.",
            "quizQuestion": "Which x64 register typically stores the return value of a function?",
            "quizOptions": [
                "RIP",
                "RSP",
                "RAX",
                "RBP"
            ],
            "correctOptionIndex": 2
        },
        {
            "id": "stack_memory",
            "type": "content",
            "title": "The Stack",
            "content": "# The Stack üìö\n\nA LIFO (Last In, First Out) memory structure.\n\n## Usage\n-   Stores **Local Variables** (int a = 5).\n-   Stores **Return Addresses** (Where to go back after a function finishes).\n-   **Push**: Add data to top.\n-   **Pop**: Remove data from top.\n\n> ‚ö†Ô∏è **Overflow**: If you write too much data to the stack, you overwrite the Return Address (Buffer Overflow exploit)."
        },
        {
            "id": "re_tools",
            "type": "content",
            "title": "RE Tools",
            "content": "# The Toolbox üß∞\n\n-   **Disassembler**: Converts binary to Assembly (IDA Pro, Ghidra).\n-   **Decompiler**: Attempts to convert Assembly back to C-like pseudocode (Ghidra, Hex-Rays).\n-   **Debugger**: Runs the code and lets you pause/inspect (x64dbg, GDB)."
        },
        {
            "id": "ghidra_vs_ida",
            "type": "content",
            "title": "Ghidra vs IDA Pro",
            "content": "# The Titans ‚öîÔ∏è\n\n-   **IDA Pro**: The industry standard. Expensive. Powerful decompiler (Hex-Rays).\n-   **Ghidra**: Free, open-source (NSA tools). Great decompiler support for many architectures.\n-   **Radare2**: Command-line based. Steep learning curve but very powerful."
        },
        {
            "id": "control_flow_graph",
            "type": "content",
            "title": "Control Flow Graph (CFG)",
            "content": "# visualizing Logic üó∫Ô∏è\n\nDisassemblers break code into \"Basic Blocks\" (instructions with no jumps inside) and confirm them with arrows.\n\n-   **Green Arrow**: Jump taken (True).\n-   **Red Arrow**: Jump not taken (False).\n\nThis makes analyzing `if` statements and loops easy visually."
        },
        {
            "id": "binary_formats",
            "type": "content",
            "title": "Binary Formats",
            "content": "# File Containers üì¶\n\n-   **PE (Portable Executable)**: Windows (`.exe`, `.dll`). Starts with `MZ`.\n-   **ELF (Executable and Linkable Format)**: Linux/Unix (`.bin`). Starts with `ELF`.\n-   **Mach-O**: macOS/iOS.\n\nThese headers tell the OS how to load the program into memory."
        },
        {
            "id": "re_patching",
            "type": "content",
            "title": "Binary Patching",
            "content": "# Modifying Code ‚úèÔ∏è\n\nChanging the binary to alter behavior.\n\n## Scenario: Cracking a Game\n-   Find the check: `cmp eax, 1` (Is license valid?)\n-   Followed by: `jz 0x401000` (Jump if Zero/False to \"Error\").\n-   **Patch**: Change `jz` (74) to `jnz` (75) or `nop` (90).\n-   **Result**: The game always thinks the license is valid."
        },
        {
            "id": "patching_code",
            "type": "content",
            "title": "Patching Concept",
            "content": "# Patcher Logic üíª\n\n```python\n# Simple Python script to patch a byte\nwith open(\"game.exe\", \"r+b\") as f:\n    f.seek(0x1A4F) # Offset of the instruction\n    byte = f.read(1)\n    print(f\"Original Byte: {byte.hex()}\")\n    \n    # Patch 0x74 (JZ) to 0xEB (JMP)\n    f.seek(0x1A4F)\n    f.write(b'\\xEB')\n    print(\"Patched!\")\n```"
        },
        {
            "id": "anti_debugging",
            "type": "content",
            "title": "Anti-Debugging",
            "content": "# Please Don't Look üôà\n\nDevelopers use tricks to crash debuggers.\n\n-   **IsDebuggerPresent()**: Windows API call.\n-   **Timing Checks**: If `GetTickCount()` shows that 5 seconds passed between two simple instructions, a human is stepping through.\n-   **Exception Handling**: Intentionally causing errors to confuse the debugger."
        },
        {
            "id": "obfuscation_packing",
            "type": "content",
            "title": "Obfuscation & Packing",
            "content": "# Hiding the Code üå´Ô∏è\n\n-   **Obfuscation**: Mangling function names, inserting junk code, encrypting strings.\n-   **Packing**: Compressing the executable. The file on disk is just a \"Unpacker Stub\" + \"Encrypted Data\".\n    -   At runtime, the Stub decrypts the Data into memory and runs it.\n    -   RE requires **Unpacking** (dumping from RAM)."
        },
        {
            "id": "static_vs_dynamic_re",
            "type": "content",
            "title": "Static vs Dynamic RE",
            "content": "# Approaches ‚òØÔ∏è\n\n-   **Static**: Reading the code (IDA/Ghidra). Safer, covers all code paths.\n-   **Dynamic**: Running the code (x64dbg). Easier to see values in registers, bypasses obfuscation (since code MUST be decrypted to run)."
        },
        {
            "id": "strings_analysis",
            "type": "content",
            "title": "Strings Analysis",
            "content": "# Lowest Hanging Fruit üçé\n\nRunning `strings binary.exe`.\n-   Reveals error messages, IP addresses, URLs, passwords, file paths.\n-   Always the first step in RE.\n-   If you see \"Usage: tool <host> <port>\", you know it's a command line tool."
        },
        {
            "id": "re_summary",
            "type": "content",
            "title": "Module Summary",
            "content": "# Wrap Up üéÅ\n\n-   **Registers**: Know your CPU (RAX, RIP).\n-   **Tools**: Master Ghidra or IDA.\n-   **Flow**: Understand logical control flow.\n-   **Patching**: Converting logical `FALSE` to `TRUE`.\n\nReverse engineering is the ultimate puzzle solving!"
        }
    ]
}