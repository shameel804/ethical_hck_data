[
    {
        "q": "What is a buffer overflow vulnerability?",
        "o": [
            "Writing data beyond allocated memory",
            "Reading files from the network",
            "Encrypting data with weak keys",
            "Parsing XML with invalid tags"
        ]
    },
    {
        "q": "Which memory region typically stores local variables?",
        "o": [
            "Stack memory",
            "Heap memory",
            "Data segment",
            "Code segment"
        ]
    },
    {
        "q": "What does shellcode typically do when executed?",
        "o": [
            "Spawns a command shell",
            "Encrypts hard drive data",
            "Deletes system registry",
            "Formats disk partitions"
        ]
    },
    {
        "q": "What is the purpose of the EIP register in x86?",
        "o": [
            "Stores next instruction address",
            "Holds current stack pointer",
            "Contains arithmetic results",
            "Manages memory allocation"
        ]
    },
    {
        "q": "What does a format string vulnerability exploit?",
        "o": [
            "Unvalidated format specifiers",
            "Buffer size miscalculations",
            "Integer type conversions",
            "Memory deallocation errors"
        ]
    },
    {
        "q": "Which function is commonly vulnerable to buffer overflow?",
        "o": [
            "strcpy()",
            "strncpy()",
            "snprintf()",
            "fgets()"
        ]
    },
    {
        "q": "What is an integer overflow?",
        "o": [
            "Value exceeds maximum storage",
            "Divide by zero operation",
            "Negative array index access",
            "Pointer arithmetic error"
        ]
    },
    {
        "q": "What does memory corruption refer to?",
        "o": [
            "Unintended modification of data",
            "Disk fragmentation issues",
            "Network bandwidth problems",
            "CPU overheating damage"
        ]
    },
    {
        "q": "Which register points to the top of the stack?",
        "o": [
            "ESP (Stack Pointer)",
            "EBP (Base Pointer)",
            "EAX (Accumulator)",
            "EDX (Data Register)"
        ]
    },
    {
        "q": "What is a NOP sled used for?",
        "o": [
            "Increasing shellcode reliability",
            "Encrypting payload data",
            "Compressing exploit code",
            "Hiding malicious content"
        ]
    },
    {
        "q": "What does the term exploit development mean?",
        "o": [
            "Creating code to abuse flaws",
            "Building secure applications",
            "Testing network firewalls",
            "Designing user interfaces"
        ]
    },
    {
        "q": "Which operator can cause integer overflow?",
        "o": [
            "Addition of large numbers",
            "String concatenation only",
            "Boolean AND operation",
            "Bitwise XOR function"
        ]
    },
    {
        "q": "What is heap memory primarily used for?",
        "o": [
            "Dynamic memory allocation",
            "Storing return addresses",
            "Holding function arguments",
            "Managing CPU registers"
        ]
    },
    {
        "q": "What does the format specifier %x print?",
        "o": [
            "Hexadecimal representation",
            "Floating point number",
            "Character string value",
            "Signed decimal integer"
        ]
    },
    {
        "q": "What causes a stack-based buffer overflow?",
        "o": [
            "Writing past stack buffer",
            "Allocating too much heap",
            "Freeing memory twice",
            "Reading null pointers"
        ]
    },
    {
        "q": "What is position independent code?",
        "o": [
            "Code that runs at any address",
            "Code that uses fixed memory",
            "Code that requires recompile",
            "Code that needs root access"
        ]
    },
    {
        "q": "Which format specifier reads from memory?",
        "o": [
            "%s reads string data",
            "%d reads decimal values",
            "%c reads single bytes",
            "%f reads float values"
        ]
    },
    {
        "q": "What is a return address in function context?",
        "o": [
            "Where execution resumes",
            "First line of code run",
            "Variable storage location",
            "Function parameter value"
        ]
    },
    {
        "q": "What does little endian byte order mean?",
        "o": [
            "Least significant byte first",
            "Most significant byte first",
            "Random byte arrangement",
            "Alphabetical byte order"
        ]
    },
    {
        "q": "What is the purpose of the EBP register?",
        "o": [
            "Frame pointer for stack",
            "Extended base processor",
            "Emergency backup pointer",
            "External buffer pointer"
        ]
    },
    {
        "q": "Which C function safely limits input size?",
        "o": [
            "fgets() with size limit",
            "gets() without checking",
            "scanf() with any format",
            "strcpy() direct copy"
        ]
    },
    {
        "q": "What is a use-after-free vulnerability?",
        "o": [
            "Accessing freed memory area",
            "Using memory before alloc",
            "Reading uninitialized data",
            "Writing to read-only zone"
        ]
    },
    {
        "q": "What does shellcode bypass typically mean?",
        "o": [
            "Evading security measures",
            "Compiling source code",
            "Debugging applications",
            "Encrypting network data"
        ]
    },
    {
        "q": "Which data type has the smallest range?",
        "o": [
            "Unsigned char (8 bit)",
            "Unsigned short integer",
            "Signed long int value",
            "Unsigned long long int"
        ]
    },
    {
        "q": "What is stack smashing?",
        "o": [
            "Overwriting stack data",
            "Compressing stack frames",
            "Encrypting stack memory",
            "Validating stack bounds"
        ]
    },
    {
        "q": "What does the printf function do?",
        "o": [
            "Formats and outputs text",
            "Reads keyboard input",
            "Allocates memory blocks",
            "Closes file descriptors"
        ]
    },
    {
        "q": "What causes a signed integer overflow?",
        "o": [
            "Exceeding max signed val",
            "Dividing by zero value",
            "Subtracting from unsigned",
            "Multiplying by negative"
        ]
    },
    {
        "q": "What is a null byte in shellcode?",
        "o": [
            "Zero byte that can terminate",
            "Random filler byte value",
            "Start of payload marker",
            "End of function symbol"
        ]
    },
    {
        "q": "What is the gets() function vulnerability?",
        "o": [
            "No buffer size checking",
            "Slow input processing",
            "Memory leak on error",
            "File handle exhaustion"
        ]
    },
    {
        "q": "What does memory layout refer to?",
        "o": [
            "Organization of program data",
            "Physical RAM arrangement",
            "Disk partition structure",
            "Network packet format"
        ]
    },
    {
        "q": "Which instruction is commonly NOP in x86?",
        "o": [
            "0x90 opcode (no operation)",
            "0xFF opcode (jump call)",
            "0x00 opcode (null byte)",
            "0xCC opcode (breakpoint)"
        ]
    },
    {
        "q": "What is an off-by-one error?",
        "o": [
            "Writing one byte too many",
            "Reading one file extra",
            "Missing one argument",
            "Skipping one function"
        ]
    },
    {
        "q": "What does the %n format specifier do?",
        "o": [
            "Writes bytes count to ptr",
            "Prints newline character",
            "Reads next number value",
            "Formats null terminated"
        ]
    },
    {
        "q": "What is buffer underflow?",
        "o": [
            "Reading before buffer start",
            "Writing past buffer end",
            "Filling buffer partially",
            "Emptying buffer contents"
        ]
    },
    {
        "q": "What does exploit reliability refer to?",
        "o": [
            "Consistent success rate",
            "Speed of execution",
            "Size of payload code",
            "Stealth of operation"
        ]
    },
    {
        "q": "Which protection uses random addresses?",
        "o": [
            "ASLR randomizes layout",
            "DEP marks pages non-exec",
            "Stack canary adds guard",
            "Control flow validates"
        ]
    },
    {
        "q": "What is a heap-based buffer overflow?",
        "o": [
            "Overflow in dynamic memory",
            "Overflow in static memory",
            "Overflow in stack memory",
            "Overflow in code segment"
        ]
    },
    {
        "q": "What does the ESP register track?",
        "o": [
            "Current stack position",
            "Exception handling ptr",
            "Extended segment ptr",
            "Execution status ptr"
        ]
    },
    {
        "q": "What is a format string attack goal?",
        "o": [
            "Read or write memory",
            "Only crash application",
            "Delete system files",
            "Encrypt stored data"
        ]
    },
    {
        "q": "Which integer type is commonly exploited?",
        "o": [
            "Size calculation values",
            "Boolean flag variables",
            "Constant defined values",
            "Enum type definitions"
        ]
    },
    {
        "q": "What makes shellcode position independent?",
        "o": [
            "No hardcoded addresses",
            "Uses only system calls",
            "Written in assembly",
            "Compiled with debug"
        ]
    },
    {
        "q": "What is a saved return pointer?",
        "o": [
            "Return addr on stack",
            "Backup of EBP value",
            "Copy of ESP register",
            "Stored EAX content"
        ]
    },
    {
        "q": "What does strcpy lack compared to strncpy?",
        "o": [
            "Length parameter check",
            "Null termination logic",
            "Character encoding check",
            "Memory allocation size"
        ]
    },
    {
        "q": "What is a double free vulnerability?",
        "o": [
            "Free same memory twice",
            "Allocate double memory",
            "Free alternate blocks",
            "Double memory access"
        ]
    },
    {
        "q": "What is the purpose of egg hunters?",
        "o": [
            "Find shellcode in memory",
            "Encrypt payload data",
            "Compress exploit code",
            "Validate target system"
        ]
    },
    {
        "q": "Which overflow affects array indexing?",
        "o": [
            "Integer overflow attack",
            "Stack buffer overflow",
            "Heap buffer overflow",
            "Format string attack"
        ]
    },
    {
        "q": "What is a stack cookie or canary?",
        "o": [
            "Guard value before return",
            "Encryption key storage",
            "Compressed data marker",
            "Function call counter"
        ]
    },
    {
        "q": "What does the BSS segment contain?",
        "o": [
            "Uninitialized global data",
            "Initialized static data",
            "Program code instructions",
            "Stack frame information"
        ]
    },
    {
        "q": "What is metasploit primarily used for?",
        "o": [
            "Exploit framework tool",
            "Web application scanner",
            "Network traffic analyzer",
            "Password cracking tool"
        ]
    },
    {
        "q": "What does a function prologue do?",
        "o": [
            "Sets up stack frame",
            "Cleans up stack frame",
            "Executes main logic",
            "Returns to caller func"
        ]
    },
    {
        "q": "What is the text segment in memory?",
        "o": [
            "Contains executable code",
            "Stores local variables",
            "Holds heap allocations",
            "Manages stack frames"
        ]
    },
    {
        "q": "What does DEP protection prevent?",
        "o": [
            "Executing data as code",
            "Reading program memory",
            "Writing to stack area",
            "Accessing heap blocks"
        ]
    },
    {
        "q": "What is a vulnerable parameter?",
        "o": [
            "Input that lacks validation",
            "Output that is encrypted",
            "Variable with fixed size",
            "Constant with known val"
        ]
    },
    {
        "q": "What does buffer size determine?",
        "o": [
            "Maximum storable data",
            "Minimum allocation unit",
            "Average memory usage",
            "Expected input format"
        ]
    },
    {
        "q": "What is an encoder in exploit development?",
        "o": [
            "Transforms shellcode bytes",
            "Compiles source to binary",
            "Debugs running process",
            "Validates input data"
        ]
    },
    {
        "q": "What causes an underflow in arithmetic?",
        "o": [
            "Result below minimum val",
            "Result above maximum val",
            "Divide by zero occurs",
            "Modulo returns negative"
        ]
    },
    {
        "q": "What is a jmp esp instruction used for?",
        "o": [
            "Redirect to stack code",
            "Clear register values",
            "Set memory permissions",
            "Call external library"
        ]
    },
    {
        "q": "What does memory corruption enable?",
        "o": [
            "Arbitrary code execution",
            "Faster program running",
            "Better memory management",
            "Improved data storage"
        ]
    },
    {
        "q": "What is a gadget in exploit terms?",
        "o": [
            "Small instruction sequence",
            "Large payload section",
            "Network exploit tool",
            "Debugging breakpoint"
        ]
    },
    {
        "q": "What is the data segment used for?",
        "o": [
            "Initialized global vars",
            "Dynamic allocations",
            "Program instructions",
            "Return addresses"
        ]
    },
    {
        "q": "What does unsigned mean for integers?",
        "o": [
            "Only positive values",
            "Only negative values",
            "Mixed sign values",
            "Floating point type"
        ]
    },
    {
        "q": "What is a payload in exploits?",
        "o": [
            "Code executed on target",
            "Initial exploit vector",
            "Vulnerability scanner",
            "Network traffic data"
        ]
    },
    {
        "q": "What does ASLR stand for?",
        "o": [
            "Address Space Layout Randomization",
            "Application Security Layer Runtime",
            "Advanced System Level Restriction",
            "Automated Security Lockdown Response"
        ]
    },
    {
        "q": "What is a function epilogue?",
        "o": [
            "Restores previous frame",
            "Initializes local vars",
            "Validates parameters",
            "Performs main logic"
        ]
    },
    {
        "q": "What does call instruction do?",
        "o": [
            "Pushes return addr and jumps",
            "Pops return addr and jumps",
            "Moves data between regs",
            "Compares two operands"
        ]
    },
    {
        "q": "What is a controlled overwrite?",
        "o": [
            "Intentional memory change",
            "Random corruption event",
            "System generated write",
            "Hardware memory fault"
        ]
    },
    {
        "q": "What does sprintf vulnerability allow?",
        "o": [
            "Format string attacks",
            "Only buffer overflows",
            "Just memory leaks",
            "Simple denial of service"
        ]
    },
    {
        "q": "What is stack frame used for?",
        "o": [
            "Function local storage",
            "Global data storage",
            "Heap memory blocks",
            "Code segment data"
        ]
    },
    {
        "q": "What does pop instruction do?",
        "o": [
            "Removes from stack top",
            "Adds to stack bottom",
            "Clears all stack data",
            "Duplicates stack entry"
        ]
    },
    {
        "q": "What is a bad character in shellcode?",
        "o": [
            "Byte that breaks exploit",
            "Extra padding bytes",
            "Encoded payload data",
            "Compressed code section"
        ]
    },
    {
        "q": "What causes heap corruption?",
        "o": [
            "Invalid heap operations",
            "Stack buffer overflow",
            "Format string bugs",
            "Integer calculation"
        ]
    },
    {
        "q": "What is a pivot in exploitation?",
        "o": [
            "Redirecting execution flow",
            "Encrypting payload data",
            "Compressing exploit code",
            "Validating input data"
        ]
    },
    {
        "q": "What does push instruction do?",
        "o": [
            "Adds value to stack",
            "Removes value from stack",
            "Clears register value",
            "Jumps to address"
        ]
    },
    {
        "q": "What is a segmentation fault?",
        "o": [
            "Invalid memory access",
            "Division by zero",
            "Stack overflow error",
            "File not found"
        ]
    },
    {
        "q": "What does ret instruction do?",
        "o": [
            "Pops and jumps to addr",
            "Pushes return address",
            "Clears all registers",
            "Sets stack pointer"
        ]
    },
    {
        "q": "What is a trampoline in exploits?",
        "o": [
            "Intermediate jump point",
            "Final payload section",
            "Initial entry point",
            "Buffer padding area"
        ]
    },
    {
        "q": "What does memory alignment mean?",
        "o": [
            "Data address boundaries",
            "Memory encryption mode",
            "Buffer size limits",
            "Stack frame order"
        ]
    },
    {
        "q": "What is an alphanumeric shellcode?",
        "o": [
            "Uses only printable chars",
            "Uses only null bytes",
            "Uses only hex values",
            "Uses only binary data"
        ]
    },
    {
        "q": "What does lea instruction do?",
        "o": [
            "Load effective address",
            "Leave current frame",
            "Link external address",
            "Lock execution area"
        ]
    },
    {
        "q": "What is a vulnerability signature?",
        "o": [
            "Pattern identifying flaw",
            "Encryption key hash",
            "User authentication",
            "Network packet header"
        ]
    },
    {
        "q": "What causes integer signedness issues?",
        "o": [
            "Mixing signed unsigned",
            "Using floating point",
            "String concatenation",
            "Boolean operations"
        ]
    },
    {
        "q": "What is the mov instruction used for?",
        "o": [
            "Copy data between locations",
            "Multiply operand values",
            "Move stack pointer up",
            "Modify program counter"
        ]
    },
    {
        "q": "What does vulnerability disclosure mean?",
        "o": [
            "Reporting security flaw",
            "Hiding exploit details",
            "Selling vulnerability",
            "Ignoring the issue"
        ]
    },
    {
        "q": "What is a polymorphic shellcode?",
        "o": [
            "Changes on each run",
            "Always stays the same",
            "Only works once",
            "Never executes fully"
        ]
    },
    {
        "q": "What does xor instruction do?",
        "o": [
            "Exclusive OR operation",
            "Extended OR operation",
            "External OR operation",
            "Exchange OR operation"
        ]
    },
    {
        "q": "What is a proof of concept exploit?",
        "o": [
            "Demonstrates vulnerability",
            "Production ready attack",
            "Theoretical analysis only",
            "Defense mechanism test"
        ]
    },
    {
        "q": "What does buffer address represent?",
        "o": [
            "Memory location start",
            "Buffer size in bytes",
            "Data type format",
            "Variable name hash"
        ]
    },
    {
        "q": "What is a staged payload?",
        "o": [
            "Loads in multiple parts",
            "Runs all at once",
            "Never fully executes",
            "Only downloads data"
        ]
    },
    {
        "q": "What does sub instruction do?",
        "o": [
            "Subtracts operand values",
            "Substitutes register data",
            "Submits system call",
            "Subdivides memory block"
        ]
    },
    {
        "q": "What is an inline payload?",
        "o": [
            "Complete in single stage",
            "Split into many parts",
            "Loaded from network",
            "Stored in file only"
        ]
    },
    {
        "q": "What does cmp instruction do?",
        "o": [
            "Compares two operands",
            "Completes program flow",
            "Compiles source code",
            "Compresses data block"
        ]
    },
    {
        "q": "What is exploit mitigation?",
        "o": [
            "Techniques to prevent attacks",
            "Methods to create exploits",
            "Ways to hide payloads",
            "Process of vulnerability"
        ]
    },
    {
        "q": "What does jmp instruction do?",
        "o": [
            "Unconditional jump to addr",
            "Jump only if zero flag",
            "Jump to system call",
            "Jump to next stack"
        ]
    },
    {
        "q": "What is a bind shell payload?",
        "o": [
            "Opens listening port",
            "Connects to attacker",
            "Executes local command",
            "Downloads file only"
        ]
    },
    {
        "q": "What does the add instruction do?",
        "o": [
            "Adds two operand values",
            "Adjusts stack pointer",
            "Allocates memory block",
            "Appends string data"
        ]
    },
    {
        "q": "What is a reverse shell payload?",
        "o": [
            "Connects back to attacker",
            "Opens port on target",
            "Only executes locally",
            "Downloads files only"
        ]
    },
    {
        "q": "How does the leave instruction work in x86?",
        "o": [
            "Restores EBP and ESP values",
            "Only clears EBP register",
            "Sets EIP to return addr",
            "Pushes all registers stack"
        ]
    },
    {
        "q": "What is the purpose of stack pivoting?",
        "o": [
            "Redirect ESP to controlled data",
            "Encrypt stack memory contents",
            "Compress stack frame size",
            "Validate return addresses"
        ]
    },
    {
        "q": "Which technique helps find buffer offset?",
        "o": [
            "Pattern generation and analysis",
            "Random value trial runs",
            "Fixed offset guessing method",
            "Database lookup queries"
        ]
    },
    {
        "q": "What does direct parameter access mean in format strings?",
        "o": [
            "Accessing specific argument directly",
            "Reading all arguments at once",
            "Writing to first param only",
            "Skipping format validation"
        ]
    },
    {
        "q": "How can integer overflow lead to buffer overflow?",
        "o": [
            "Small buffer allocated due to wrap",
            "Large buffer causes memory leak",
            "Negative buffer prevents alloc",
            "Zero buffer triggers exception"
        ]
    },
    {
        "q": "What is a write primitive in exploitation?",
        "o": [
            "Ability to write arbitrary memory",
            "Only reading memory addresses",
            "Executing code in memory",
            "Allocating new memory blocks"
        ]
    },
    {
        "q": "What encoding technique avoids null bytes?",
        "o": [
            "XOR encoding with key value",
            "Base64 standard encoding",
            "Plain ASCII text format",
            "Binary to decimal convert"
        ]
    },
    {
        "q": "What is the purpose of a decoder stub?",
        "o": [
            "Decode encoded shellcode at runtime",
            "Compress payload before sending",
            "Encrypt communication channel",
            "Validate payload integrity"
        ]
    },
    {
        "q": "How does stack-based buffer overflow bypass ASLR?",
        "o": [
            "Using info leak to find addr",
            "Stack is never randomized",
            "Overflow disables ASLR",
            "Direct address guessing"
        ]
    },
    {
        "q": "What is a format string direct write?",
        "o": [
            "Using %n to write value directly",
            "Printf without format args",
            "Sprintf to buffer overflow",
            "Scanf without input check"
        ]
    },
    {
        "q": "What happens on signed to unsigned conversion?",
        "o": [
            "Negative becomes large positive",
            "Value remains exactly same",
            "Result is always zero",
            "Compiler generates error"
        ]
    },
    {
        "q": "What is heap metadata corruption?",
        "o": [
            "Overwriting heap mgmt structs",
            "Reading heap contents only",
            "Allocating new heap blocks",
            "Freeing heap correctly"
        ]
    },
    {
        "q": "What does a syscall instruction do in shellcode?",
        "o": [
            "Invokes kernel functionality",
            "Returns to user space",
            "Allocates memory blocks",
            "Jumps to library code"
        ]
    },
    {
        "q": "How is SEH exploited on Windows?",
        "o": [
            "Overwriting exception handler ptr",
            "Bypassing stack protection",
            "Disabling DEP completely",
            "Modifying kernel structures"
        ]
    },
    {
        "q": "What is a short jump vs long jump?",
        "o": [
            "Range of bytes that can be jumped",
            "Speed of jump execution time",
            "Direction of jump forward back",
            "Number of jumps per function"
        ]
    },
    {
        "q": "What does the int 0x80 instruction do on Linux?",
        "o": [
            "Triggers system call interrupt",
            "Interrupts all processes now",
            "Sets interrupt flag only",
            "Returns from interrupt"
        ]
    },
    {
        "q": "What is an info leak vulnerability?",
        "o": [
            "Discloses memory addr or data",
            "Only causes system crash",
            "Deletes files from disk",
            "Modifies config settings"
        ]
    },
    {
        "q": "How does %p differ from %x in format strings?",
        "o": [
            "Prints pointer with prefix 0x",
            "Prints as decimal integer",
            "Writes value to address",
            "Reads from memory address"
        ]
    },
    {
        "q": "What is size_t typically used for?",
        "o": [
            "Unsigned type for sizes lengths",
            "Signed type for time values",
            "Floating point precision",
            "Boolean true false vals"
        ]
    },
    {
        "q": "What is chunk in heap terminology?",
        "o": [
            "Unit of heap allocation",
            "Section of stack frame",
            "Part of code segment",
            "Block of BSS data"
        ]
    },
    {
        "q": "What makes mmap based allocs different?",
        "o": [
            "Allocated separately from heap",
            "Always on the stack",
            "Never freed by system",
            "Only for small sizes"
        ]
    },
    {
        "q": "What is the purpose of execve syscall?",
        "o": [
            "Execute new program image",
            "Allocate memory blocks",
            "Open file descriptors",
            "Close network sockets"
        ]
    },
    {
        "q": "How does SafeSEH protection work?",
        "o": [
            "Validates handler against list",
            "Encrypts exception handlers",
            "Randomizes handler addresses",
            "Prevents all exceptions"
        ]
    },
    {
        "q": "What is conditional jump in shellcode?",
        "o": [
            "Jump based on flag value",
            "Jump that always executes",
            "Jump to fixed address",
            "Jump to random place"
        ]
    },
    {
        "q": "What is the purpose of dup2 syscall?",
        "o": [
            "Duplicate file descriptor to num",
            "Open two files at once",
            "Close descriptor twice",
            "Read from two sources"
        ]
    },
    {
        "q": "How do you identify buffer overflow in binary?",
        "o": [
            "Find unsafe functions in code",
            "Run program with debugger",
            "Check network traffic",
            "Analyze disk usage"
        ]
    },
    {
        "q": "What does short write mean in format strings?",
        "o": [
            "Writing two bytes at a time",
            "Writing one byte per call",
            "Writing full word at once",
            "Writing zero bytes only"
        ]
    },
    {
        "q": "What is wraparound in integer operations?",
        "o": [
            "Value cycles back after max",
            "Value stays at maximum",
            "Value becomes negative",
            "Value resets to zero"
        ]
    },
    {
        "q": "What is the unlink macro in glibc heap?",
        "o": [
            "Removes chunk from free list",
            "Links new chunk to heap",
            "Allocates new memory block",
            "Frees all heap chunks"
        ]
    },
    {
        "q": "How does shellcode avoid string functions?",
        "o": [
            "Works with null bytes inline",
            "Uses only string copies",
            "Relies on strlen calls",
            "Depends on strcmp func"
        ]
    },
    {
        "q": "What is SEHOP protection on Windows?",
        "o": [
            "Validates SEH chain integrity",
            "Encrypts all exceptions",
            "Disables SEH completely",
            "Randomizes all handlers"
        ]
    },
    {
        "q": "What does relative addressing enable?",
        "o": [
            "Position independent memory access",
            "Fixed address calculations",
            "Hardcoded offset values",
            "Static memory references"
        ]
    },
    {
        "q": "What syscall creates a new process on Linux?",
        "o": [
            "fork() creates child process",
            "exec() runs new program",
            "open() starts process",
            "read() loads binary"
        ]
    },
    {
        "q": "What is control flow hijacking?",
        "o": [
            "Redirecting program execution",
            "Stopping program running",
            "Slowing down execution",
            "Speeding up control flow"
        ]
    },
    {
        "q": "How does dollar sign work in format strings?",
        "o": [
            "Specifies parameter position num",
            "Prints currency symbols",
            "Ends the format string",
            "Starts variable name"
        ]
    },
    {
        "q": "What is truncation in integer operations?",
        "o": [
            "High bits lost on conversion",
            "Value extended with zeros",
            "Sign bit is preserved",
            "All bits are kept"
        ]
    },
    {
        "q": "What is the fastbin in glibc heap?",
        "o": [
            "Singly linked list for small chunks",
            "Doubly linked for large ones",
            "Tree structure for all sizes",
            "Array for mmap allocations"
        ]
    },
    {
        "q": "What is the purpose of setreuid syscall?",
        "o": [
            "Set real and effective user IDs",
            "Read user ID from file",
            "Create new user account",
            "Delete user from system"
        ]
    },
    {
        "q": "What does gs and fs segment registers hold?",
        "o": [
            "Thread local storage pointers",
            "Global variable addresses",
            "Stack frame pointers",
            "Code segment offsets"
        ]
    },
    {
        "q": "What is call near vs call far?",
        "o": [
            "Within segment vs cross segment",
            "Fast vs slow function call",
            "Short vs long distance",
            "Direct vs indirect call"
        ]
    },
    {
        "q": "What is the width specifier in format strings?",
        "o": [
            "Minimum characters to output",
            "Maximum string length",
            "Number of bytes to read",
            "Precision of decimal"
        ]
    },
    {
        "q": "How does sign extension work?",
        "o": [
            "Fills high bits with sign bit",
            "Fills high bits with zeros",
            "Clears all high bits",
            "Copies low bits to high"
        ]
    },
    {
        "q": "What is tcache in modern glibc?",
        "o": [
            "Thread local cache for speed",
            "Global cache for all threads",
            "Disk cache for malloc",
            "Network cache for data"
        ]
    },
    {
        "q": "What makes x64 shellcode different from x86?",
        "o": [
            "Different registers and syscalls",
            "Exactly the same as x86",
            "Only uses 32 bit regs",
            "Cannot execute on 64bit"
        ]
    },
    {
        "q": "What is stack unwinding in exceptions?",
        "o": [
            "Walking back through stack frames",
            "Adding new stack entries",
            "Compressing stack data",
            "Encrypting stack content"
        ]
    },
    {
        "q": "What does the test instruction do?",
        "o": [
            "Bitwise AND and set flags",
            "Tests memory allocation",
            "Validates register values",
            "Checks stack integrity"
        ]
    },
    {
        "q": "What is precision specifier in format strings?",
        "o": [
            "Max chars for string output",
            "Minimum field width size",
            "Number of decimal places",
            "Padding character choice"
        ]
    },
    {
        "q": "What is the difference between malloc and calloc?",
        "o": [
            "calloc initializes memory to zero",
            "malloc is always faster",
            "calloc allocates on stack",
            "malloc cannot fail"
        ]
    },
    {
        "q": "What is the unsorted bin in glibc heap?",
        "o": [
            "Holding area before sorting bins",
            "Final storage for all chunks",
            "Only for sorted chunks",
            "Cache for small sizes"
        ]
    },
    {
        "q": "How do you find libc base in ASLR?",
        "o": [
            "Leak address and calc offset",
            "Base is always known",
            "Disable ASLR first",
            "Guess random values"
        ]
    },
    {
        "q": "What is GS cookie on Windows?",
        "o": [
            "Stack buffer overrun detection",
            "Heap corruption protection",
            "Code integrity validation",
            "Network session token"
        ]
    },
    {
        "q": "What does cdecl calling convention specify?",
        "o": [
            "Caller cleans up stack args",
            "Callee cleans up stack",
            "Args passed in registers",
            "No cleanup is needed"
        ]
    },
    {
        "q": "What is hh modifier in format strings?",
        "o": [
            "Specifies char sized arg",
            "Half double precision",
            "Hexadecimal output mode",
            "High byte only print"
        ]
    },
    {
        "q": "What is the relationship between size and security?",
        "o": [
            "Smaller buffers more risky",
            "Larger buffers always safe",
            "Size has no effect",
            "Only heap size matters"
        ]
    },
    {
        "q": "What is the largebin in glibc heap?",
        "o": [
            "Sorted bins for big chunks",
            "Unsorted small chunk bin",
            "Cache for tiny allocs",
            "Mmap based allocations"
        ]
    },
    {
        "q": "What is the purpose of socket syscall in shellcode?",
        "o": [
            "Create network socket endpoint",
            "Close existing connections",
            "Read from socket buffer",
            "Write to socket queue"
        ]
    },
    {
        "q": "What is CFG on Windows?",
        "o": [
            "Control Flow Guard protection",
            "Config File Generator tool",
            "Core Function Gateway",
            "Crash Failure Guard sys"
        ]
    },
    {
        "q": "What does stdcall convention specify?",
        "o": [
            "Callee cleans up stack args",
            "Caller cleans up stack",
            "All args in registers",
            "Stack not used at all"
        ]
    },
    {
        "q": "What is the purpose of length modifier l?",
        "o": [
            "Specifies long int argument",
            "Limits output length",
            "Left aligns output",
            "Lowercase hex output"
        ]
    },
    {
        "q": "What is bounds checking?",
        "o": [
            "Validating index within limits",
            "Checking file permissions",
            "Verifying network bounds",
            "Testing memory speed"
        ]
    },
    {
        "q": "What is consolidation in heap management?",
        "o": [
            "Merging adjacent free chunks",
            "Splitting large allocations",
            "Compacting used memory",
            "Defragmenting heap space"
        ]
    },
    {
        "q": "What is the connect syscall used for?",
        "o": [
            "Establish connection to address",
            "Disconnect from remote host",
            "Accept incoming connection",
            "Listen on local port"
        ]
    },
    {
        "q": "What is RELRO protection?",
        "o": [
            "Makes GOT read-only",
            "Randomizes return addrs",
            "Encrypts library calls",
            "Validates all returns"
        ]
    },
    {
        "q": "What is fastcall convention?",
        "o": [
            "First args passed in regs",
            "All args passed on stack",
            "Callee cleans all args",
            "No registers are used"
        ]
    },
    {
        "q": "What is the z length modifier?",
        "o": [
            "Specifies size_t argument type",
            "Zero pads the output",
            "Compresses the string",
            "Zips format output"
        ]
    },
    {
        "q": "What is input sanitization?",
        "o": [
            "Cleaning dangerous input chars",
            "Encrypting user input",
            "Compressing input data",
            "Storing input to file"
        ]
    },
    {
        "q": "What is top chunk in glibc heap?",
        "o": [
            "Chunk at end of heap arena",
            "First allocated chunk",
            "Smallest free chunk",
            "Largest used chunk"
        ]
    },
    {
        "q": "What is the bind syscall used for?",
        "o": [
            "Associate socket with address",
            "Connect to remote server",
            "Accept incoming request",
            "Close socket descriptor"
        ]
    },
    {
        "q": "What is PIE in binary protection?",
        "o": [
            "Position Independent Executable",
            "Protected Integer Encoding",
            "Pointer Integrity Engine",
            "Process Isolation Ext"
        ]
    },
    {
        "q": "What is thiscall convention?",
        "o": [
            "this ptr passed in ECX reg",
            "All args passed by stack",
            "No special treatment this",
            "This passed as last arg"
        ]
    },
    {
        "q": "What does the star in format strings do?",
        "o": [
            "Takes width from argument",
            "Prints asterisk character",
            "Multiplies the output",
            "Repeats format pattern"
        ]
    },
    {
        "q": "What is defense in depth?",
        "o": [
            "Multiple protection layers",
            "Single strong defense",
            "Depth of stack only",
            "Deep code analysis"
        ]
    },
    {
        "q": "What is arena in glibc heap?",
        "o": [
            "Heap region for allocations",
            "Stack frame container",
            "Code section boundary",
            "Data segment area"
        ]
    },
    {
        "q": "What is the listen syscall used for?",
        "o": [
            "Mark socket for connections",
            "Connect to remote host",
            "Send data to socket",
            "Close socket handle"
        ]
    },
    {
        "q": "What is Fortify Source protection?",
        "o": [
            "Compile time buffer checks",
            "Runtime stack cookies",
            "Address randomization",
            "Code signing validation"
        ]
    },
    {
        "q": "What is the System V AMD64 ABI?",
        "o": [
            "Standard 64-bit calling conv",
            "32-bit legacy interface",
            "Windows only standard",
            "Kernel calling method"
        ]
    },
    {
        "q": "What is the minus flag in format strings?",
        "o": [
            "Left justify the output",
            "Print negative numbers",
            "Subtract from value",
            "Decrease precision"
        ]
    },
    {
        "q": "What is code review for security?",
        "o": [
            "Manual source examination",
            "Automated testing only",
            "Running the program",
            "Compiling with debug"
        ]
    },
    {
        "q": "What is the chunk header in heap?",
        "o": [
            "Metadata before user data",
            "User data at the start",
            "Pointer to next chunk",
            "Size of previous alloc"
        ]
    },
    {
        "q": "What is the accept syscall used for?",
        "o": [
            "Accept incoming connection",
            "Connect to remote server",
            "Bind to local address",
            "Listen on socket port"
        ]
    },
    {
        "q": "What is NX bit?",
        "o": [
            "No execute memory page flag",
            "Next instruction pointer",
            "Network exchange bit",
            "Null exception handler"
        ]
    },
    {
        "q": "What registers pass args in x64 Linux?",
        "o": [
            "rdi rsi rdx rcx r8 r9",
            "rax rbx rcx rdx rsp",
            "eax ebx ecx edx esi",
            "All arguments on stack"
        ]
    },
    {
        "q": "What is the plus flag in format strings?",
        "o": [
            "Always show sign for numbers",
            "Add values together",
            "Increase output width",
            "Concatenate strings"
        ]
    },
    {
        "q": "What is fuzzing in exploit development?",
        "o": [
            "Automated random input testing",
            "Manual code review only",
            "Static binary analysis",
            "Network traffic capture"
        ]
    },
    {
        "q": "What determines chunk size calculation?",
        "o": [
            "User size plus metadata",
            "Only user requested size",
            "Fixed system page size",
            "Random allocation size"
        ]
    },
    {
        "q": "What is the read syscall used for?",
        "o": [
            "Read data from descriptor",
            "Write data to file desc",
            "Open new file handle",
            "Close existing handle"
        ]
    },
    {
        "q": "What is W xor X memory protection?",
        "o": [
            "Pages writable or exec not both",
            "Both writable and executable",
            "Neither writable nor exec",
            "Only kernel can execute"
        ]
    },
    {
        "q": "What is the red zone in x64?",
        "o": [
            "128 bytes below RSP for use",
            "Protected memory region",
            "Stack overflow boundary",
            "Heap guard area size"
        ]
    },
    {
        "q": "What is the space flag in format strings?",
        "o": [
            "Prefix positive with space",
            "Add spaces between chars",
            "Trim trailing spaces",
            "Remove all whitespace"
        ]
    },
    {
        "q": "What is static analysis?",
        "o": [
            "Analyzing without execution",
            "Running with debugger",
            "Testing in sandbox",
            "Monitoring network"
        ]
    },
    {
        "q": "What is prev_size field in chunk?",
        "o": [
            "Size of previous chunk when free",
            "Size of current chunk data",
            "Pointer to next free chunk",
            "Flags for chunk status"
        ]
    },
    {
        "q": "What is the write syscall used for?",
        "o": [
            "Write data to descriptor",
            "Read data from file",
            "Create new file entry",
            "Delete existing file"
        ]
    },
    {
        "q": "What is stack smashing protector?",
        "o": [
            "GCC option for stack canaries",
            "Heap overflow protection",
            "Format string prevention",
            "Integer overflow check"
        ]
    },
    {
        "q": "What is shadow stack?",
        "o": [
            "Separate copy of return addrs",
            "Backup of all registers",
            "Mirror of heap memory",
            "Duplicate of code section"
        ]
    },
    {
        "q": "What is the hash flag in format strings?",
        "o": [
            "Alternate form like 0x prefix",
            "Hash the output value",
            "Comment out the format",
            "End the format string"
        ]
    },
    {
        "q": "What is dynamic analysis?",
        "o": [
            "Analyzing during execution",
            "Reading source code only",
            "Disassembling binary",
            "Reviewing documentation"
        ]
    },
    {
        "q": "What is the purpose of mprotect syscall?",
        "o": [
            "Change memory page permissions",
            "Allocate new memory region",
            "Free existing memory block",
            "Copy data between regions"
        ]
    },
    {
        "q": "How does ROP chain bypass DEP protection?",
        "o": [
            "Uses existing executable code",
            "Disables hardware DEP support",
            "Writes to executable pages",
            "Executes shellcode directly"
        ]
    },
    {
        "q": "What is the purpose of GOT overwrite?",
        "o": [
            "Redirect function call target",
            "Protect global variables",
            "Encrypt function addresses",
            "Validate function pointers"
        ]
    },
    {
        "q": "What is a format string arbitrary read?",
        "o": [
            "Reading memory at any address",
            "Writing to specified location",
            "Executing code at address",
            "Allocating memory blocks"
        ]
    },
    {
        "q": "How do integer overflow checks work?",
        "o": [
            "Verify operation does not wrap",
            "Allow all calculations",
            "Only check after operation",
            "Disable overflow completely"
        ]
    },
    {
        "q": "What is the house of force technique?",
        "o": [
            "Overwrite top chunk size field",
            "Force malloc to return ptr",
            "Corrupt fastbin freelist",
            "Modify unsorted bin links"
        ]
    },
    {
        "q": "What is shellcode staging?",
        "o": [
            "Downloading larger payload",
            "Executing all code at once",
            "Compressing shellcode data",
            "Encrypting payload bytes"
        ]
    },
    {
        "q": "What is the purpose of ROPgadget tool?",
        "o": [
            "Find gadgets in binaries",
            "Create new shellcode",
            "Debug running exploits",
            "Compile exploit code"
        ]
    },
    {
        "q": "How does partial overwrite work?",
        "o": [
            "Overwriting only some bytes",
            "Full address replacement",
            "Clearing entire memory",
            "Encrypting partial data"
        ]
    },
    {
        "q": "What is GOT and PLT relationship?",
        "o": [
            "PLT jumps to GOT entries",
            "GOT contains PLT code",
            "PLT stores addresses",
            "GOT is code section"
        ]
    },
    {
        "q": "What does width padding achieve in format strings?",
        "o": [
            "Controls bytes written count",
            "Formats output alignment only",
            "Encrypts the output data",
            "Compresses string length"
        ]
    },
    {
        "q": "What is safe integer arithmetic library?",
        "o": [
            "Checks ops before execution",
            "Allows all operations",
            "Only validates results",
            "Ignores overflow errors"
        ]
    },
    {
        "q": "What is the house of lore technique?",
        "o": [
            "Corrupt smallbin for alloc",
            "Overwrite top chunk size",
            "Modify fastbin freelist",
            "Change unsorted bin ptr"
        ]
    },
    {
        "q": "What is socket reuse in shellcode?",
        "o": [
            "Reusing existing connection",
            "Opening multiple sockets",
            "Closing all connections",
            "Creating new socket"
        ]
    },
    {
        "q": "What is ret2libc attack?",
        "o": [
            "Return to library functions",
            "Return to shellcode only",
            "Return to kernel code",
            "Return to data section"
        ]
    },
    {
        "q": "What is one-byte overwrite exploitation?",
        "o": [
            "Overwrite single byte for effect",
            "Write entire address at once",
            "Clear one byte per frame",
            "Read single byte values"
        ]
    },
    {
        "q": "What is lazy binding in dynamic linking?",
        "o": [
            "Resolve symbols when called first",
            "Resolve all symbols at start",
            "Never resolve any symbols",
            "Resolve symbols randomly"
        ]
    },
    {
        "q": "What does format string %ln specifier do?",
        "o": [
            "Write count as long integer",
            "Print long number value",
            "Read long from memory",
            "Format long precision"
        ]
    },
    {
        "q": "What is integer promotion in C?",
        "o": [
            "Small types become int size",
            "All types become char",
            "Values stay same size",
            "Only pointers promoted"
        ]
    },
    {
        "q": "What is the house of spirit technique?",
        "o": [
            "Free fake chunk for malloc",
            "Force top chunk overflow",
            "Corrupt smallbin pointers",
            "Modify chunk metadata"
        ]
    },
    {
        "q": "What is getdents used for in shellcode?",
        "o": [
            "Read directory entries",
            "Get file descriptors",
            "Open network sockets",
            "Write to file handle"
        ]
    },
    {
        "q": "What is ret2csu attack technique?",
        "o": [
            "Use __libc_csu_init gadgets",
            "Return to custom shellcode",
            "Call system directly",
            "Jump to main function"
        ]
    },
    {
        "q": "What is null byte poisoning?",
        "o": [
            "Overwrite with null byte",
            "Inject null into output",
            "Read null terminated str",
            "Clear all null values"
        ]
    },
    {
        "q": "What is LD_PRELOAD used for?",
        "o": [
            "Load library before others",
            "Disable library loading",
            "Encrypt loaded libraries",
            "Validate library paths"
        ]
    },
    {
        "q": "What is format string GOT overwrite?",
        "o": [
            "Use %n to modify GOT entry",
            "Read GOT addresses only",
            "Encrypt all GOT values",
            "Validate GOT integrity"
        ]
    },
    {
        "q": "What is comparison vulnerability in integer?",
        "o": [
            "Signed vs unsigned compare bug",
            "Equal comparison always true",
            "Greater than always fails",
            "Less than never matches"
        ]
    },
    {
        "q": "What is the house of einherjar technique?",
        "o": [
            "Null byte off-by-one exploit",
            "Overwrite top chunk size",
            "Corrupt fastbin freelist",
            "Modify unsorted bin link"
        ]
    },
    {
        "q": "What is setsockopt used for in shellcode?",
        "o": [
            "Configure socket options",
            "Create new socket conn",
            "Close socket descriptor",
            "Read from socket buf"
        ]
    },
    {
        "q": "What is stack pivot gadget?",
        "o": [
            "Changes ESP to new location",
            "Clears all stack data",
            "Encrypts stack content",
            "Validates stack bounds"
        ]
    },
    {
        "q": "What is off-by-one in heap context?",
        "o": [
            "Single byte heap overflow",
            "One chunk allocation",
            "Free one extra block",
            "Read one byte only"
        ]
    },
    {
        "q": "What does BIND_NOW linker flag do?",
        "o": [
            "Resolve symbols at load time",
            "Delay symbol resolution",
            "Disable symbol lookup",
            "Encrypt symbol table"
        ]
    },
    {
        "q": "What is format string partial write?",
        "o": [
            "Overwrite only needed bytes",
            "Write full address value",
            "Read partial memory addr",
            "Clear partial buffer"
        ]
    },
    {
        "q": "What is multiplication overflow?",
        "o": [
            "Product exceeds max value",
            "Result is always zero",
            "Only happens with zero",
            "Never occurs in practice"
        ]
    },
    {
        "q": "What is tcache poisoning attack?",
        "o": [
            "Corrupt tcache for arb alloc",
            "Only affects fastbin list",
            "Modifies unsorted bin",
            "Changes top chunk size"
        ]
    },
    {
        "q": "What is chroot used for in shellcode?",
        "o": [
            "Change apparent root directory",
            "Create new user account",
            "Read file permissions",
            "Write to system files"
        ]
    },
    {
        "q": "What is magic gadget in exploitation?",
        "o": [
            "One gadget that does it all",
            "Multiple gadgets chained",
            "Encrypted shellcode",
            "Compressed payload"
        ]
    },
    {
        "q": "What is heap spray technique?",
        "o": [
            "Fill heap with shellcode copies",
            "Clear all heap memory",
            "Encrypt heap contents",
            "Compress heap data"
        ]
    },
    {
        "q": "What is DT_RPATH used for?",
        "o": [
            "Specify library search paths",
            "Disable library loading",
            "Encrypt library names",
            "Validate library code"
        ]
    },
    {
        "q": "What is format string blind write?",
        "o": [
            "Writing without seeing result",
            "Reading all memory blocks",
            "Clear format specifiers",
            "Encrypt all output"
        ]
    },
    {
        "q": "What is division by zero in security?",
        "o": [
            "Can cause denial of service",
            "Always handled safely",
            "Never occurs in code",
            "Only in floating point"
        ]
    },
    {
        "q": "What is fastbin dup attack?",
        "o": [
            "Double free same fastbin chunk",
            "Allocate from empty bin",
            "Free chunk to wrong bin",
            "Merge two fastbin lists"
        ]
    },
    {
        "q": "What is seccomp used for in exploitation?",
        "o": [
            "Restrict syscalls available",
            "Enable all syscalls",
            "Encrypt syscall args",
            "Validate syscall results"
        ]
    },
    {
        "q": "What is two's complement overflow?",
        "o": [
            "Sign bit change on overflow",
            "Value becomes unsigned",
            "All bits become zero",
            "Only affects low byte"
        ]
    },
    {
        "q": "What is overlapping chunks attack?",
        "o": [
            "Make chunks share memory region",
            "Separate all heap chunks",
            "Encrypt chunk boundaries",
            "Validate chunk sizes"
        ]
    },
    {
        "q": "What is RUNPATH vs RPATH?",
        "o": [
            "RUNPATH can be overridden",
            "RPATH has lower priority",
            "Both are equivalent",
            "Neither affects loading"
        ]
    },
    {
        "q": "What is format string leak technique?",
        "o": [
            "Use %p or %x to read stack",
            "Write values to memory",
            "Execute remote code",
            "Allocate new memory"
        ]
    },
    {
        "q": "What is array index out of bounds?",
        "o": [
            "Access beyond array limits",
            "Index starts at one",
            "Array is too small",
            "Only affects strings"
        ]
    },
    {
        "q": "What is unsorted bin attack?",
        "o": [
            "Write libc addr to target",
            "Read unsorted bin list",
            "Clear unsorted entries",
            "Sort all bin chunks"
        ]
    },
    {
        "q": "What is prctl used for?",
        "o": [
            "Control process attributes",
            "Create new process",
            "Kill running process",
            "Read process memory"
        ]
    },
    {
        "q": "What is call chain analysis?",
        "o": [
            "Trace function call paths",
            "Count function calls",
            "Encrypt call parameters",
            "Compress call stack"
        ]
    },
    {
        "q": "What is uninitialized variable vulnerability?",
        "o": [
            "Using var before setting value",
            "Setting variable twice",
            "Clearing variable value",
            "Reading constant value"
        ]
    },
    {
        "q": "What is largebin attack technique?",
        "o": [
            "Write heap addr to target",
            "Read largebin content",
            "Clear largebin list",
            "Sort largebin entries"
        ]
    },
    {
        "q": "What is capstone in exploit development?",
        "o": [
            "Disassembly framework tool",
            "Assembler for shellcode",
            "Debugger application",
            "Network scanner tool"
        ]
    },
    {
        "q": "What is vtable hijacking?",
        "o": [
            "Overwrite virtual func table",
            "Protect function pointers",
            "Encrypt table entries",
            "Validate call targets"
        ]
    },
    {
        "q": "What is type confusion vulnerability?",
        "o": [
            "Object treated as wrong type",
            "Correct type always used",
            "Type checked at runtime",
            "Static type validation"
        ]
    },
    {
        "q": "What is FILE structure exploitation?",
        "o": [
            "Corrupt stdio FILE struct",
            "Protect file operations",
            "Encrypt file handles",
            "Validate file pointers"
        ]
    },
    {
        "q": "What is keystone in exploit development?",
        "o": [
            "Assembler framework tool",
            "Disassembly library",
            "Debugger interface",
            "Network protocol lib"
        ]
    },
    {
        "q": "What is CFI bypass technique?",
        "o": [
            "Trick control flow checks",
            "Disable all CFI protections",
            "Encrypt function calls",
            "Validate all branches"
        ]
    },
    {
        "q": "What is race condition vulnerability?",
        "o": [
            "Time-of-check to time-of-use bug",
            "Single threaded issue only",
            "Always happens in order",
            "Timing is guaranteed"
        ]
    },
    {
        "q": "What is _IO_vtable_check bypass?",
        "o": [
            "Evade FILE vtable validation",
            "Enable vtable checking",
            "Encrypt vtable content",
            "Validate all vtables"
        ]
    },
    {
        "q": "What is unicorn engine used for?",
        "o": [
            "CPU emulation framework",
            "Disassembly tool only",
            "Assembly compiler",
            "Network scanner"
        ]
    },
    {
        "q": "What is SROP attack technique?",
        "o": [
            "Signal return oriented programming",
            "Stack return optimization",
            "System return operation",
            "Secure return protocol"
        ]
    },
    {
        "q": "What is dangling pointer vulnerability?",
        "o": [
            "Pointer to freed memory",
            "Pointer to valid data",
            "Null pointer value",
            "Stack pointer issue"
        ]
    },
    {
        "q": "What is _rtld_global exploitation?",
        "o": [
            "Corrupt dynamic linker data",
            "Protect loader structures",
            "Encrypt linker paths",
            "Validate symbol lookup"
        ]
    },
    {
        "q": "What is pwntools in exploitation?",
        "o": [
            "CTF exploit dev framework",
            "Static analysis tool",
            "Malware scanner app",
            "Network proxy server"
        ]
    },
    {
        "q": "What is JIT spray attack?",
        "o": [
            "Use JIT compiler for shell",
            "Disable JIT compilation",
            "Encrypt JIT output",
            "Validate JIT code"
        ]
    },
    {
        "q": "What is null pointer dereference?",
        "o": [
            "Read or write at address zero",
            "Valid memory access",
            "Stack memory error",
            "Heap allocation bug"
        ]
    },
    {
        "q": "What is libc database used for?",
        "o": [
            "Find libc version from leak",
            "Encrypt libc symbols",
            "Disable libc functions",
            "Validate libc calls"
        ]
    },
    {
        "q": "What is angr tool used for?",
        "o": [
            "Binary analysis platform",
            "Shellcode encoder",
            "Network scanner app",
            "Malware detector"
        ]
    },
    {
        "q": "What is COP attack technique?",
        "o": [
            "Call oriented programming",
            "Code optimization process",
            "Control over pointer",
            "Cryptographic operation"
        ]
    },
    {
        "q": "What is wild pointer?",
        "o": [
            "Uninitialized pointer value",
            "Valid memory pointer",
            "Null pointer constant",
            "Stack frame pointer"
        ]
    },
    {
        "q": "What is one_gadget tool?",
        "o": [
            "Find execve gadgets in libc",
            "Create custom shellcode",
            "Encrypt payload bytes",
            "Validate gadget chains"
        ]
    },
    {
        "q": "What is radare2 used for?",
        "o": [
            "Reverse engineering framework",
            "Shellcode compiler only",
            "Network traffic analyzer",
            "Malware scanner tool"
        ]
    },
    {
        "q": "What is JOP attack technique?",
        "o": [
            "Jump oriented programming",
            "Just-in-time optimization",
            "Java object protocol",
            "JIT operation procedure"
        ]
    },
    {
        "q": "What is memory disclosure vulnerability?",
        "o": [
            "Leak sensitive memory data",
            "Protect memory contents",
            "Encrypt all memory",
            "Validate memory access"
        ]
    },
    {
        "q": "What is ropper tool used for?",
        "o": [
            "Find ROP gadgets in binary",
            "Create new shellcode",
            "Encrypt exploit payload",
            "Validate gadget sequence"
        ]
    },
    {
        "q": "What is GDB scripting used for?",
        "o": [
            "Automate debugging tasks",
            "Compile source code",
            "Encrypt debug output",
            "Validate breakpoints"
        ]
    },
    {
        "q": "What is BROP attack technique?",
        "o": [
            "Blind return oriented prog",
            "Binary return operation",
            "Base register offset",
            "Buffer read operation"
        ]
    },
    {
        "q": "What is stale pointer vulnerability?",
        "o": [
            "Pointer to reallocated memory",
            "Pointer to static data",
            "Fresh pointer value",
            "Null pointer constant"
        ]
    },
    {
        "q": "What is checksec tool used for?",
        "o": [
            "Check binary security features",
            "Create new exploits",
            "Encrypt binary files",
            "Validate source code"
        ]
    },
    {
        "q": "What is peda GDB extension?",
        "o": [
            "Enhanced debugging features",
            "Just basic GDB wrapper",
            "Exploit compiler tool",
            "Network analysis plugin"
        ]
    },
    {
        "q": "What is DOP attack technique?",
        "o": [
            "Data oriented programming",
            "Direct operation protocol",
            "Dynamic offset pointer",
            "Debug output procedure"
        ]
    },
    {
        "q": "What is object lifetime vulnerability?",
        "o": [
            "Use object after destruction",
            "Object always valid",
            "Lifetime is infinite",
            "Construction never fails"
        ]
    },
    {
        "q": "What is gef GDB extension?",
        "o": [
            "GDB enhanced features tool",
            "Graph execution flow",
            "Generate exploit file",
            "Grep exploit format"
        ]
    },
    {
        "q": "What is heap feng shui?",
        "o": [
            "Heap layout manipulation",
            "Random heap allocation",
            "Encrypted heap data",
            "Validated heap size"
        ]
    },
    {
        "q": "What is exploitation primitive?",
        "o": [
            "Basic capability for exploit",
            "Complex attack chain",
            "Encrypted payload data",
            "Validated input value"
        ]
    },
    {
        "q": "What does negative array index allow?",
        "o": [
            "Access memory before array",
            "Only allocate more space",
            "Clear all array data",
            "Sort array elements"
        ]
    },
    {
        "q": "What is ghidra used for?",
        "o": [
            "Reverse engineering tool",
            "Exploit development only",
            "Network traffic capture",
            "Malware creation tool"
        ]
    },
    {
        "q": "What is heap grooming?",
        "o": [
            "Prepare heap for exploit",
            "Clean unused heap blocks",
            "Encrypt heap content",
            "Validate heap metadata"
        ]
    },
    {
        "q": "What is arbitrary read primitive?",
        "o": [
            "Read any memory address",
            "Write to any location",
            "Execute code anywhere",
            "Allocate any size"
        ]
    },
    {
        "q": "What causes integer underflow in unsigned?",
        "o": [
            "Subtract from zero value",
            "Add two large numbers",
            "Multiply by negative",
            "Divide by large num"
        ]
    },
    {
        "q": "What is binary ninja used for?",
        "o": [
            "Binary analysis platform",
            "Shellcode compiler only",
            "Network packet capture",
            "Malware creation kit"
        ]
    },
    {
        "q": "What is house of orange technique?",
        "o": [
            "Abuse _IO_flush_all for shell",
            "Overwrite top chunk only",
            "Corrupt fastbin freelist",
            "Modify unsorted bin link"
        ]
    },
    {
        "q": "What is arbitrary write primitive?",
        "o": [
            "Write to any memory addr",
            "Read any location",
            "Execute code anywhere",
            "Allocate any size"
        ]
    },
    {
        "q": "What is signed right shift behavior?",
        "o": [
            "Preserves sign bit value",
            "Always fills with zero",
            "Undefined in all cases",
            "Clears entire value"
        ]
    },
    {
        "q": "What is IDA Pro used for?",
        "o": [
            "Disassembly and analysis",
            "Shellcode creation only",
            "Network scanning tool",
            "Malware distribution"
        ]
    },
    {
        "q": "What is house of rabbit technique?",
        "o": [
            "Fastbin into smallbin trick",
            "Overwrite top chunk size",
            "Corrupt unsorted bin",
            "Modify largebin entry"
        ]
    },
    {
        "q": "What is code execution primitive?",
        "o": [
            "Ability to run arbitrary code",
            "Only read memory content",
            "Write data to memory",
            "Allocate heap blocks"
        ]
    },
    {
        "q": "What is implicit cast vulnerability?",
        "o": [
            "Compiler converts type wrong",
            "Explicit cast always safe",
            "No conversion happens",
            "Type is preserved"
        ]
    },
    {
        "q": "What is hopper used for?",
        "o": [
            "Disassembler for macOS",
            "Shellcode generator",
            "Network scanner tool",
            "Malware creator app"
        ]
    },
    {
        "q": "How does tcache double free differ from fastbin?",
        "o": [
            "No double free check in old glibc",
            "Identical protection mechanism",
            "Tcache never allows double free",
            "Fastbin has weaker protection"
        ]
    },
    {
        "q": "What is __malloc_hook exploitation?",
        "o": [
            "Overwrite hook to call func",
            "Protect malloc operations",
            "Encrypt allocation sizes",
            "Validate malloc results"
        ]
    },
    {
        "q": "How does partial RELRO differ from full?",
        "o": [
            "GOT still writable in partial",
            "Both make GOT read-only",
            "Partial has no protection",
            "Full allows GOT writes"
        ]
    },
    {
        "q": "What is pointer authentication on ARM?",
        "o": [
            "Cryptographic ptr validation",
            "Simple null check only",
            "Address randomization",
            "Stack canary equivalent"
        ]
    },
    {
        "q": "How does seccomp-bpf filter syscalls?",
        "o": [
            "BPF program checks each call",
            "Simple allow deny list",
            "Only blocks network calls",
            "Prevents all syscalls"
        ]
    },
    {
        "q": "What is __free_hook exploitation?",
        "o": [
            "Overwrite to control free calls",
            "Protect free operations",
            "Encrypt freed addresses",
            "Validate free targets"
        ]
    },
    {
        "q": "What is BTI on ARM processors?",
        "o": [
            "Branch Target Identification",
            "Base Type Indicator val",
            "Binary Type Inspection",
            "Byte Transfer Index"
        ]
    },
    {
        "q": "How does MTE work on ARM?",
        "o": [
            "Memory tagging extension check",
            "Multi-thread encryption",
            "Machine type encoding",
            "Module transfer enable"
        ]
    },
    {
        "q": "What is __realloc_hook used for?",
        "o": [
            "Intercept realloc calls",
            "Protect reallocation",
            "Encrypt new sizes",
            "Validate old blocks"
        ]
    },
    {
        "q": "What is CET shadow stack on Intel?",
        "o": [
            "Hardware protected return addrs",
            "Software only protection",
            "Memory encryption feature",
            "Cache optimization tech"
        ]
    },
    {
        "q": "How does house of banana work?",
        "o": [
            "Corrupt link_map for code exec",
            "Overwrite heap metadata",
            "Modify stack canaries",
            "Change GOT entries"
        ]
    },
    {
        "q": "What is tcache key in modern glibc?",
        "o": [
            "Double free detection value",
            "Encryption key for data",
            "Cache lookup index",
            "Thread identification"
        ]
    },
    {
        "q": "What is Intel CET IBT?",
        "o": [
            "Indirect Branch Tracking",
            "Internal Byte Transfer",
            "Instruction Block Test",
            "Integrated Bus Tech"
        ]
    },
    {
        "q": "How does house of botcake work?",
        "o": [
            "Consolidation with tcache abuse",
            "Direct heap overwrite only",
            "Stack buffer manipulation",
            "GOT pointer corruption"
        ]
    },
    {
        "q": "What is safe linking protection?",
        "o": [
            "XOR next ptr with position",
            "Simple null byte check",
            "Address encryption only",
            "Size field validation"
        ]
    },
    {
        "q": "What is ARM PAC bypass technique?",
        "o": [
            "Use PAC signing gadgets",
            "Disable PAC completely",
            "Ignore all signatures",
            "Encrypt all pointers"
        ]
    },
    {
        "q": "How does house of husk work?",
        "o": [
            "Abuse printf function hooks",
            "Direct shellcode execution",
            "Stack overflow exploit",
            "Heap metadata corrupt"
        ]
    },
    {
        "q": "What is ASAN memory protection?",
        "o": [
            "Address sanitizer detection",
            "Automatic security algo",
            "Advanced stack analysis",
            "Async signal handler"
        ]
    },
    {
        "q": "What is glibc tcache stashing unlink?",
        "o": [
            "Smallbin to tcache exploit",
            "Tcache size validation",
            "Fastbin corruption",
            "Largebin attack"
        ]
    },
    {
        "q": "What is hardware memory tagging?",
        "o": [
            "Tag bits checked on access",
            "Encrypt all memory data",
            "Compress memory blocks",
            "Validate all pointers"
        ]
    },
    {
        "q": "How does __memalign_hook work?",
        "o": [
            "Hook for aligned allocations",
            "Protect alignment calls",
            "Encrypt aligned blocks",
            "Validate alignment"
        ]
    },
    {
        "q": "What is CFI shadow in LLVM?",
        "o": [
            "Bitmap for type checking",
            "Stack shadow copy",
            "Heap metadata backup",
            "Code segment mirror"
        ]
    },
    {
        "q": "What is house of kiwi technique?",
        "o": [
            "Abuse __malloc_assert path",
            "Direct code execution",
            "Stack overflow method",
            "Heap spray technique"
        ]
    },
    {
        "q": "What is HWASAN for Android?",
        "o": [
            "Hardware assisted sanitizer",
            "Heap write address scan",
            "Hot wire access secure",
            "High water addr sync"
        ]
    },
    {
        "q": "How does exit handler exploitation work?",
        "o": [
            "Corrupt __exit_funcs list",
            "Only affects main return",
            "Modifies stack directly",
            "Changes heap metadata"
        ]
    },
    {
        "q": "What is MSAN memory protection?",
        "o": [
            "Memory sanitizer for uninit",
            "Malloc security analysis",
            "Multi-stack address net",
            "Machine state accessor"
        ]
    },
    {
        "q": "What is house of emma technique?",
        "o": [
            "Abuse pointer guard value",
            "Direct heap overflow",
            "Stack canary bypass",
            "GOT overwrite method"
        ]
    },
    {
        "q": "What is glibc pointer mangling?",
        "o": [
            "XOR ptr with secret value",
            "Simple encryption only",
            "Address randomization",
            "Size field obfuscation"
        ]
    },
    {
        "q": "How does TSAN find race conditions?",
        "o": [
            "Thread sanitizer detection",
            "Trace stack allocations",
            "Test secure addresses",
            "Taint sensitive allocs"
        ]
    },
    {
        "q": "What is libc 2.34+ hook removal?",
        "o": [
            "Hooks removed for security",
            "Hooks still available",
            "New hooks added instead",
            "Hook location changed"
        ]
    },
    {
        "q": "What is KASAN for kernel?",
        "o": [
            "Kernel address sanitizer",
            "Key allocation secure alloc",
            "Kernel async signal addr",
            "Known address sync API"
        ]
    },
    {
        "q": "How does house of pig work?",
        "o": [
            "FILE __read_base exploit",
            "Direct stack overflow",
            "Heap spray technique",
            "GOT corruption only"
        ]
    },
    {
        "q": "What is __libc_stack_end exploitation?",
        "o": [
            "Leak stack address value",
            "Protect stack boundary",
            "Encrypt stack content",
            "Validate stack size"
        ]
    },
    {
        "q": "What is stack clash attack?",
        "o": [
            "Collide stack with heap guard",
            "Normal stack overflow",
            "Heap buffer overrun",
            "Format string attack"
        ]
    },
    {
        "q": "How does house of cat work?",
        "o": [
            "FILE vtable manipulation new",
            "Traditional heap overflow",
            "Stack smashing attack",
            "GOT pointer overwrite"
        ]
    },
    {
        "q": "What is __environ exploitation?",
        "o": [
            "Leak or write stack addr",
            "Protect environment vars",
            "Encrypt env pointers",
            "Validate env access"
        ]
    },
    {
        "q": "What is kernel SMAP protection?",
        "o": [
            "Supervisor mode access prevent",
            "Stack memory address prot",
            "Secure mode allocation",
            "System map address prot"
        ]
    },
    {
        "q": "How does poison null byte work?",
        "o": [
            "Null overwrites size field",
            "Just terminates strings",
            "Clears entire buffer",
            "Encrypts the data"
        ]
    },
    {
        "q": "What is __libc_argv exploitation?",
        "o": [
            "Leak or modify stack data",
            "Protect argument values",
            "Encrypt argv content",
            "Validate arg count"
        ]
    },
    {
        "q": "What is kernel SMEP protection?",
        "o": [
            "Supervisor mode exec prevent",
            "Stack memory exec prot",
            "Secure mode encrypt page",
            "System mode escape prot"
        ]
    },
    {
        "q": "How does extending freed chunk work?",
        "o": [
            "Fake larger size for overlap",
            "Simply free more memory",
            "Clear all chunk data",
            "Encrypt chunk contents"
        ]
    },
    {
        "q": "What is TLS exploitation?",
        "o": [
            "Thread local storage attack",
            "Transport layer security",
            "Triple linked structure",
            "Tainted local scope"
        ]
    },
    {
        "q": "What is KASLR in kernel?",
        "o": [
            "Kernel address randomization",
            "Known address security log",
            "Kernel async system lock",
            "Key allocation secure lib"
        ]
    },
    {
        "q": "How does shrinking freed chunk work?",
        "o": [
            "Fake smaller for partial use",
            "Simply allocate less mem",
            "Clear remaining data",
            "Encrypt partial chunk"
        ]
    },
    {
        "q": "What is fs segment attack on x64?",
        "o": [
            "Corrupt thread local data",
            "File system manipulation",
            "Frame stack attack",
            "Function segment mod"
        ]
    },
    {
        "q": "What is KPTI for kernel isolation?",
        "o": [
            "Kernel page table isolation",
            "Key protection type ind",
            "Kernel proc table init",
            "Known page transfer idx"
        ]
    },
    {
        "q": "How does forged chunk header work?",
        "o": [
            "Create fake chunk metadata",
            "Simply overwrite data",
            "Clear chunk contents",
            "Encrypt header fields"
        ]
    },
    {
        "q": "What is canary brute force attack?",
        "o": [
            "Leak canary byte by byte",
            "Guess entire canary",
            "Disable canary check",
            "Encrypt canary value"
        ]
    },
    {
        "q": "What is kernel KALSR bypass?",
        "o": [
            "Leak kernel address somehow",
            "Disable randomization",
            "Guess kernel base addr",
            "Encrypt kernel pointers"
        ]
    },
    {
        "q": "How does fake vtable work in FILE?",
        "o": [
            "Point to controlled data",
            "Validate all vtables",
            "Encrypt vtable pointer",
            "Protect vtable area"
        ]
    },
    {
        "q": "What is format string stack read?",
        "o": [
            "Dump stack via %p or %x",
            "Write to stack values",
            "Execute stack code",
            "Allocate stack space"
        ]
    },
    {
        "q": "What is ret2dir attack?",
        "o": [
            "Return to direct kernel map",
            "Return to directory path",
            "Redirect to directory",
            "Restore to default"
        ]
    },
    {
        "q": "How does fake arena work in glibc?",
        "o": [
            "Create controlled heap region",
            "Simply allocate memory",
            "Clear arena contents",
            "Encrypt arena data"
        ]
    },
    {
        "q": "What is ROP vs JOP difference?",
        "o": [
            "Return vs jump based gadgets",
            "Identical attack methods",
            "ROP is newer technique",
            "JOP uses stack only"
        ]
    },
    {
        "q": "What is physmap spray attack?",
        "o": [
            "Userspace data in kernel map",
            "Physical memory encrypt",
            "Page map protection",
            "Process memory spray"
        ]
    },
    {
        "q": "How does controlled chunk size help?",
        "o": [
            "Target specific bin type",
            "Just makes code faster",
            "Clear more data at once",
            "Encrypt larger blocks"
        ]
    },
    {
        "q": "What is sigreturn frame forgery?",
        "o": [
            "Fake signal context frame",
            "Real signal handling",
            "Stack frame creation",
            "Return addr protection"
        ]
    },
    {
        "q": "What is kernel usermodehelper attack?",
        "o": [
            "Trigger userspace from kernel",
            "User memory protection",
            "Helper thread creation",
            "Mode transition defense"
        ]
    },
    {
        "q": "How does IOV_MAX limit exploitation?",
        "o": [
            "Writev size check bypass",
            "Maximum file write size",
            "IO vector encryption",
            "Variable buffer limit"
        ]
    },
    {
        "q": "What is mmap to writable exploit?",
        "o": [
            "Map executable as writable",
            "Simple file mapping",
            "Memory protection only",
            "Address randomization"
        ]
    },
    {
        "q": "What is modprobe_path attack?",
        "o": [
            "Kernel global for module load",
            "Module protection path",
            "Process probe value",
            "Memory probe address"
        ]
    },
    {
        "q": "How does coalesce control exploitation work?",
        "o": [
            "Control which chunks merge",
            "Just free all memory",
            "Clear merge flags",
            "Encrypt merge data"
        ]
    },
    {
        "q": "What is SROP frame constraints?",
        "o": [
            "Register values in context",
            "Simple return only",
            "Signal protection mode",
            "Return addr validation"
        ]
    },
    {
        "q": "What is core_pattern attack?",
        "o": [
            "Kernel crash handler exploit",
            "Core file protection",
            "Pattern matching bypass",
            "Crash dump encryption"
        ]
    },
    {
        "q": "How does FD hijacking work in heap?",
        "o": [
            "Overwrite forward pointer",
            "File descriptor attack",
            "Function data hijack",
            "Frame displacement mod"
        ]
    },
    {
        "q": "What is syscall instruction encoding?",
        "o": [
            "0x0f 0x05 on x64 Linux",
            "0x80 0x00 on all arch",
            "0xcc 0xcd on Intel",
            "0x90 0x90 everywhere"
        ]
    },
    {
        "q": "What is poweroff_cmd attack?",
        "o": [
            "Kernel shutdown cmd exploit",
            "Power management protect",
            "Command execution block",
            "Shutdown prevention"
        ]
    },
    {
        "q": "How does BK hijacking work in heap?",
        "o": [
            "Overwrite backward pointer",
            "Block key modification",
            "Binary kernel hijack",
            "Base key manipulation"
        ]
    },
    {
        "q": "What is rop chain stack alignment?",
        "o": [
            "16 byte align for calls",
            "No alignment needed",
            "8 byte is sufficient",
            "32 byte required always"
        ]
    },
    {
        "q": "What is orderly_poweroff attack?",
        "o": [
            "Kernel function ptr exploit",
            "Orderly shutdown protect",
            "Power sequence defense",
            "Ordered cleanup method"
        ]
    },
    {
        "q": "How does in-place editing exploit work?",
        "o": [
            "Modify active chunk data",
            "Edit file in current loc",
            "Change place values",
            "Insert place marker"
        ]
    },
    {
        "q": "What is movaps crash on x64?",
        "o": [
            "SSE requires 16 byte align",
            "Move operation failure",
            "Access permission error",
            "Stack alignment issue"
        ]
    },
    {
        "q": "What is call_usermodehelper exploit?",
        "o": [
            "Run userspace from kernel",
            "Call user functions",
            "Helper mode activation",
            "User call protection"
        ]
    },
    {
        "q": "How does adjacent chunk corruption work?",
        "o": [
            "Overflow into next chunk",
            "Corrupt random memory",
            "Clear adjacent data",
            "Encrypt nearby chunks"
        ]
    },
    {
        "q": "What is one gadget constraints?",
        "o": [
            "Register values needed for exec",
            "Single gadget limitation",
            "One instruction only",
            "Constraint not needed"
        ]
    },
    {
        "q": "What is commit_creds exploit?",
        "o": [
            "Kernel priv escalation func",
            "Credential commitment",
            "Credit validation call",
            "Commit protection"
        ]
    },
    {
        "q": "How does tcache count bypass work?",
        "o": [
            "Exceed max tcache entries",
            "Reset count to zero",
            "Clear all entries",
            "Encrypt count value"
        ]
    },
    {
        "q": "What is leave ret gadget use?",
        "o": [
            "Stack pivot then return",
            "Just leave function",
            "Return immediately",
            "Leave data on stack"
        ]
    },
    {
        "q": "What is prepare_kernel_cred exploit?",
        "o": [
            "Create root credentials",
            "Prepare credential struct",
            "Kernel prep function",
            "Cred validation call"
        ]
    },
    {
        "q": "How does tcache key corruption work?",
        "o": [
            "Overwrite to bypass check",
            "Generate new key val",
            "Clear key completely",
            "Encrypt corrupt key"
        ]
    },
    {
        "q": "What is pop rdi ret gadget for?",
        "o": [
            "Set first argument value",
            "Pop random value",
            "Return to pop addr",
            "Direct system call"
        ]
    },
    {
        "q": "What is switch_task_namespaces exploit?",
        "o": [
            "Change process namespaces",
            "Switch task context",
            "Namespace protection",
            "Task validation call"
        ]
    },
    {
        "q": "How does fake tcache struct work?",
        "o": [
            "Forge tcache perthread struct",
            "Create simple cache",
            "Clear tcache data",
            "Encrypt struct fields"
        ]
    },
    {
        "q": "What is pop rsi ret gadget for?",
        "o": [
            "Set second argument value",
            "Pop stack item only",
            "Return to pop location",
            "Direct function call"
        ]
    },
    {
        "q": "What is find_task_by_vpid exploit?",
        "o": [
            "Locate process for attack",
            "Find task protection",
            "VP identifier lookup",
            "PID validation method"
        ]
    },
    {
        "q": "How does fd_nextsize corruption work?",
        "o": [
            "Corrupt largebin ptr fields",
            "Next size validation",
            "File desc modification",
            "Forward size update"
        ]
    },
    {
        "q": "What is pop rdx ret gadget for?",
        "o": [
            "Set third argument value",
            "Pop data register only",
            "Return direct to func",
            "Direct memory write"
        ]
    },
    {
        "q": "What is kernel n_tty_ops exploit?",
        "o": [
            "TTY operations table attack",
            "Normal TTY operation",
            "Network TTY protect",
            "Type operation field"
        ]
    },
    {
        "q": "How does bk_nextsize corruption work?",
        "o": [
            "Corrupt largebin back ptr",
            "Back size validation",
            "Block key next field",
            "Backward size update"
        ]
    },
    {
        "q": "What is pop rcx ret gadget for?",
        "o": [
            "Set fourth argument value",
            "Pop counter register",
            "Return to count func",
            "Direct counter set"
        ]
    },
    {
        "q": "What is setxattr heap spray?",
        "o": [
            "Kernel alloc with user data",
            "Set extended attribute",
            "Extra attribute protect",
            "Attribute validation"
        ]
    },
    {
        "q": "How does malloc consolidate exploitation work?",
        "o": [
            "Trigger consolidation for overlap",
            "Simple malloc call",
            "Clear consolidate flag",
            "Encrypt consolidated chunk"
        ]
    },
    {
        "q": "What is pop r8 ret gadget for?",
        "o": [
            "Set fifth argument value",
            "Pop register eight val",
            "Return to r8 address",
            "Direct register set"
        ]
    },
    {
        "q": "What is userfaultfd exploitation?",
        "o": [
            "Pause kernel at fault point",
            "User fault handler",
            "File descriptor fault",
            "Fault protection"
        ]
    },
    {
        "q": "How does fake mp_ struct work?",
        "o": [
            "Forge malloc parameters",
            "Make pointer struct",
            "Clear mp values",
            "Encrypt parameters"
        ]
    },
    {
        "q": "What is pop r9 ret gadget for?",
        "o": [
            "Set sixth argument value",
            "Pop register nine val",
            "Return to r9 address",
            "Direct register nine"
        ]
    },
    {
        "q": "What is msg_msg exploitation?",
        "o": [
            "Kernel message queue abuse",
            "Message protection mode",
            "Messaging validation",
            "Queue protection call"
        ]
    },
    {
        "q": "How does fake main_arena work?",
        "o": [
            "Forge arena structure fields",
            "Create main allocation",
            "Clear arena values",
            "Encrypt arena struct"
        ]
    },
    {
        "q": "What is xchg eax esp gadget for?",
        "o": [
            "Stack pivot to controlled",
            "Exchange register only",
            "EAX becomes pointer",
            "ESP stores value"
        ]
    },
    {
        "q": "What is sk_buff exploitation?",
        "o": [
            "Kernel network buffer abuse",
            "Socket buffer protect",
            "Buffer validation mode",
            "Network protection"
        ]
    },
    {
        "q": "How does pipe_buffer kernel exploit work?",
        "o": [
            "Corrupt pipe buffer operations",
            "Simple pipe read write",
            "Buffer protection mode",
            "Pipe validation call"
        ]
    },
    {
        "q": "What is timerfd_ctx exploitation?",
        "o": [
            "Kernel timer struct abuse",
            "Timer protection mode",
            "File descriptor time",
            "Context validation"
        ]
    },
    {
        "q": "How does key_type kernel struct help?",
        "o": [
            "Controlled ops table attack",
            "Key protection system",
            "Type validation mode",
            "Struct protection"
        ]
    },
    {
        "q": "What is kmalloc cache attack?",
        "o": [
            "Target specific slab cache",
            "General heap spray",
            "Cache protection mode",
            "Allocation validation"
        ]
    },
    {
        "q": "How does seq_operations exploitation work?",
        "o": [
            "Leak or call via vtable",
            "Sequence protection mode",
            "Operation validation",
            "Seq protection call"
        ]
    },
    {
        "q": "What is tty_struct kernel exploit?",
        "o": [
            "TTY with controlled ops",
            "Terminal protection mode",
            "Structure validation",
            "TTY protection call"
        ]
    },
    {
        "q": "How does cred struct overwrite work?",
        "o": [
            "Directly modify uid gid values",
            "Credential protection",
            "Structure validation",
            "Overwrite protection"
        ]
    },
    {
        "q": "What is shmem_inode kernel attack?",
        "o": [
            "Shared memory inode abuse",
            "Memory protection mode",
            "Inode validation call",
            "Share protection"
        ]
    },
    {
        "q": "How does poll_list kernel exploit work?",
        "o": [
            "Heap spray with poll struct",
            "Poll protection mode",
            "List validation call",
            "Protection mechanism"
        ]
    },
    {
        "q": "What is msg_msgseg exploitation?",
        "o": [
            "Message segment heap control",
            "Segment protection mode",
            "Message validation",
            "Seg protection call"
        ]
    },
    {
        "q": "How does simple_xattr kernel struct help?",
        "o": [
            "Cross cache spray object",
            "Simple protection mode",
            "Attribute validation",
            "Xattr protection"
        ]
    },
    {
        "q": "What is user_key_payload kernel attack?",
        "o": [
            "Arbitrary size heap alloc",
            "Key protection mode",
            "Payload validation",
            "User protection call"
        ]
    },
    {
        "q": "How does signalfd_ctx exploitation work?",
        "o": [
            "Signal fd struct attack",
            "Signal protection mode",
            "Context validation",
            "FD protection call"
        ]
    },
    {
        "q": "What is nft_object kernel exploit?",
        "o": [
            "Netfilter object abuse",
            "Object protection mode",
            "NFT validation call",
            "Filter protection"
        ]
    },
    {
        "q": "How does io_uring kernel attack work?",
        "o": [
            "Async IO subsystem abuse",
            "IO protection mode",
            "Ring validation call",
            "Uring protection"
        ]
    },
    {
        "q": "What is bpf_map kernel exploitation?",
        "o": [
            "BPF map struct attack",
            "Map protection mode",
            "BPF validation call",
            "Protection mechanism"
        ]
    },
    {
        "q": "How does slab cross cache attack work?",
        "o": [
            "Free to different cache",
            "Cache protection mode",
            "Cross validation call",
            "Slab protection"
        ]
    },
    {
        "q": "What is struct file kernel exploit?",
        "o": [
            "File operations vtable",
            "File protection mode",
            "Struct validation",
            "File protection call"
        ]
    },
    {
        "q": "How does page table walk work?",
        "o": [
            "Translate virtual to physical",
            "Walk protection mode",
            "Table validation call",
            "Page protection"
        ]
    },
    {
        "q": "What is vmalloc kernel heap attack?",
        "o": [
            "Virtual kernel heap spray",
            "Malloc protection mode",
            "Alloc validation call",
            "Vmalloc protection"
        ]
    },
    {
        "q": "How does workqueue_struct exploit work?",
        "o": [
            "Work queue function poison",
            "Queue protection mode",
            "Work validation call",
            "Struct protection"
        ]
    },
    {
        "q": "What is kobject kernel exploitation?",
        "o": [
            "Kernel object kops abuse",
            "Object protection mode",
            "Kobject validation",
            "Protection mechanism"
        ]
    },
    {
        "q": "How does cpu_entry_area attack work?",
        "o": [
            "Per CPU entry area abuse",
            "CPU protection mode",
            "Entry validation call",
            "Area protection"
        ]
    },
    {
        "q": "What is socket_alloc kernel exploit?",
        "o": [
            "Socket allocation abuse",
            "Alloc protection mode",
            "Socket validation",
            "Protection call"
        ]
    },
    {
        "q": "How does kmem_cache_alloc control work?",
        "o": [
            "Control cache for exploit",
            "Cache protection mode",
            "Alloc validation call",
            "Kmem protection"
        ]
    },
    {
        "q": "What is dentry kernel exploitation?",
        "o": [
            "Directory entry struct abuse",
            "Dentry protection mode",
            "Entry validation call",
            "Protection mechanism"
        ]
    },
    {
        "q": "How does inode ops poisoning work?",
        "o": [
            "Corrupt inode operations",
            "Inode protection mode",
            "Ops validation call",
            "Poison protection"
        ]
    },
    {
        "q": "What is netlink socket kernel attack?",
        "o": [
            "Netlink struct exploitation",
            "Socket protection mode",
            "Netlink validation",
            "Protection mechanism"
        ]
    },
    {
        "q": "How does kfree_skb kernel primitive work?",
        "o": [
            "Free network buffer control",
            "SKB protection mode",
            "Free validation call",
            "Kfree protection"
        ]
    },
    {
        "q": "What is fs_struct kernel exploit?",
        "o": [
            "Filesystem struct attack",
            "FS protection mode",
            "Struct validation",
            "Protection mechanism"
        ]
    },
    {
        "q": "How does namespace escape kernel work?",
        "o": [
            "Break out of namespace",
            "Namespace protection",
            "Escape validation call",
            "Protection mechanism"
        ]
    },
    {
        "q": "What is seccomp bypass kernel technique?",
        "o": [
            "Evade syscall filtering",
            "Seccomp protection mode",
            "Bypass validation call",
            "Protection mechanism"
        ]
    },
    {
        "q": "How does task_struct overwrite work?",
        "o": [
            "Modify process struct",
            "Task protection mode",
            "Struct validation call",
            "Overwrite protection"
        ]
    },
    {
        "q": "What is mm_struct kernel exploitation?",
        "o": [
            "Memory map struct attack",
            "MM protection mode",
            "Struct validation call",
            "Protection mechanism"
        ]
    },
    {
        "q": "How does vma_area_struct exploit work?",
        "o": [
            "Virtual memory area abuse",
            "VMA protection mode",
            "Area validation call",
            "Struct protection"
        ]
    },
    {
        "q": "What is nsproxy kernel attack?",
        "o": [
            "Namespace proxy abuse",
            "Proxy protection mode",
            "NS validation call",
            "Protection mechanism"
        ]
    },
    {
        "q": "How does kernel stack pivot work?",
        "o": [
            "Control RSP in kernel",
            "Stack protection mode",
            "Pivot validation call",
            "Protection mechanism"
        ]
    },
    {
        "q": "What is pte manipulation attack?",
        "o": [
            "Page table entry modify",
            "PTE protection mode",
            "Entry validation call",
            "Manipulation prot"
        ]
    },
    {
        "q": "How does double fetch kernel bug work?",
        "o": [
            "TOCTOU with user memory",
            "Fetch protection mode",
            "Double validation call",
            "Bug protection"
        ]
    },
    {
        "q": "What is priv escalation via kernel?",
        "o": [
            "Get root from vuln kernel",
            "Privilege protection",
            "Escalation validation",
            "Protection mechanism"
        ]
    },
    {
        "q": "How does kernel info leak help?",
        "o": [
            "Bypass KASLR and defenses",
            "Leak protection mode",
            "Info validation call",
            "Protection mechanism"
        ]
    },
    {
        "q": "What is SLUB allocator attack?",
        "o": [
            "Linux default allocator abuse",
            "SLUB protection mode",
            "Allocator validation",
            "Protection mechanism"
        ]
    },
    {
        "q": "How does SLAB allocator differ from SLUB?",
        "o": [
            "Colored caches and queues",
            "Identical implementation",
            "SLAB is faster always",
            "SLUB has no metadata"
        ]
    },
    {
        "q": "What is SLOB allocator used for?",
        "o": [
            "Embedded systems small mem",
            "General purpose Linux",
            "Enterprise servers only",
            "Desktop systems only"
        ]
    },
    {
        "q": "How does kmemdup primitive work?",
        "o": [
            "Kernel memory duplicate",
            "Memory protection mode",
            "Dup validation call",
            "Protection mechanism"
        ]
    },
    {
        "q": "What is copy_from_user vulnerability?",
        "o": [
            "Race during user copy",
            "Copy protection mode",
            "User validation call",
            "Protection mechanism"
        ]
    },
    {
        "q": "How does kernel code reuse attack work?",
        "o": [
            "ROP JOP in kernel context",
            "Reuse protection mode",
            "Attack validation call",
            "Protection mechanism"
        ]
    },
    {
        "q": "What is kernel heap groom technique?",
        "o": [
            "Prepare slab for exploit",
            "Groom protection mode",
            "Heap validation call",
            "Protection mechanism"
        ]
    },
    {
        "q": "How does kmalloc-cg cache differ?",
        "o": [
            "Cgroup isolated slab caches",
            "Same as normal kmalloc",
            "No isolation at all",
            "Only for containers"
        ]
    },
    {
        "q": "What is elastic object technique?",
        "o": [
            "Variable size kernel obj",
            "Fixed size objects only",
            "Object protection mode",
            "Elastic protection"
        ]
    },
    {
        "q": "How does cross cache attack work?",
        "o": [
            "Target object in diff cache",
            "Same cache attack only",
            "Cross protection mode",
            "Attack validation"
        ]
    },
    {
        "q": "What is kernel object reuse attack?",
        "o": [
            "UAF with reallocated obj",
            "Reuse protection mode",
            "Object validation call",
            "Protection mechanism"
        ]
    },
    {
        "q": "How does kernel page spray work?",
        "o": [
            "Fill pages with content",
            "Spray protection mode",
            "Page validation call",
            "Protection mechanism"
        ]
    },
    {
        "q": "What is FREELIST_RANDOM protection?",
        "o": [
            "Randomize slab freelist",
            "No randomization done",
            "Free protection mode",
            "Random validation"
        ]
    },
    {
        "q": "How does FREELIST_HARDENED work?",
        "o": [
            "XOR freelist with cookie",
            "No hardening applied",
            "Hardened protection mode",
            "Freelist validation"
        ]
    },
    {
        "q": "What is INIT_ON_ALLOC protection?",
        "o": [
            "Zero memory on allocation",
            "No initialization done",
            "Alloc protection mode",
            "Init validation call"
        ]
    },
    {
        "q": "How does INIT_ON_FREE work?",
        "o": [
            "Sanitize memory on free",
            "No sanitization applied",
            "Free protection mode",
            "Init validation call"
        ]
    },
    {
        "q": "What is kernel pointer leak mitigation?",
        "o": [
            "Restrict addr via kptr_restrict",
            "No restriction applied",
            "Pointer protection mode",
            "Leak validation call"
        ]
    },
    {
        "q": "How does dmesg_restrict work?",
        "o": [
            "Limit kernel log access",
            "No restrictions applied",
            "Dmesg protection mode",
            "Restrict validation"
        ]
    },
    {
        "q": "What is sysfs kernel info leak?",
        "o": [
            "Kernel addrs via sysfs",
            "Sysfs protection mode",
            "Info validation call",
            "Leak protection"
        ]
    },
    {
        "q": "How does randomize_kstack_offset work?",
        "o": [
            "Per syscall stack offset",
            "Fixed stack always",
            "Randomize prot mode",
            "Offset validation"
        ]
    },
    {
        "q": "What is RANDSTRUCT kernel protection?",
        "o": [
            "Randomize struct layout",
            "Fixed struct layout",
            "Struct protection mode",
            "Random validation call"
        ]
    },
    {
        "q": "How does spectre mitigation work in kernel?",
        "o": [
            "Retpolines and barriers",
            "No mitigation applied",
            "Spectre protection mode",
            "Mitigation validation"
        ]
    },
    {
        "q": "What is meltdown kernel mitigation?",
        "o": [
            "KPTI page table isolation",
            "No kernel isolation",
            "Meltdown prot mode",
            "Mitigation validation"
        ]
    },
    {
        "q": "How does kernel CFI work?",
        "o": [
            "Type based call validation",
            "No call validation done",
            "CFI protection mode",
            "Kernel validation call"
        ]
    },
    {
        "q": "What is kernel shadow call stack?",
        "o": [
            "Separate return address copy",
            "No shadow stack used",
            "Shadow protection mode",
            "Call stack validation"
        ]
    },
    {
        "q": "How does memory tagging for kernel work?",
        "o": [
            "MTE for kernel memory",
            "No tagging in kernel",
            "Tag protection mode",
            "Memory validation call"
        ]
    },
    {
        "q": "What is BTI for kernel branches?",
        "o": [
            "Branch target validation",
            "No branch protection",
            "BTI protection mode",
            "Branch validation call"
        ]
    },
    {
        "q": "How does PAN protection work?",
        "o": [
            "Prevent kernel user access",
            "Allow all user access",
            "PAN protection mode",
            "Access validation call"
        ]
    },
    {
        "q": "What is PXN kernel protection?",
        "o": [
            "No exec from user pages",
            "Execute user pages ok",
            "PXN protection mode",
            "Exec validation call"
        ]
    },
    {
        "q": "How does UAO in ARM work?",
        "o": [
            "User access override bit",
            "No user override mode",
            "UAO protection mode",
            "Access validation call"
        ]
    },
    {
        "q": "What is kernel pointer encode?",
        "o": [
            "Obfuscate kernel pointers",
            "No ptr obfuscation",
            "Encode protection mode",
            "Pointer validation call"
        ]
    },
    {
        "q": "How does kernel stack guard page work?",
        "o": [
            "Unmapped page detects overflow",
            "No guard pages used",
            "Guard protection mode",
            "Stack validation call"
        ]
    },
    {
        "q": "What is VMAP stack protection?",
        "o": [
            "Virtually mapped kernel stacks",
            "Physically contiguous stacks",
            "VMAP protection mode",
            "Stack validation call"
        ]
    },
    {
        "q": "How does kernel lockdown work?",
        "o": [
            "Restrict root capabilities",
            "No lockdown applied",
            "Lockdown protection mode",
            "Kernel validation call"
        ]
    },
    {
        "q": "What is loadpin security module?",
        "o": [
            "Restrict kernel module load",
            "Allow all module loads",
            "Loadpin protection mode",
            "Module validation call"
        ]
    },
    {
        "q": "How does IMA work for kernel?",
        "o": [
            "Integrity measurement arch",
            "No integrity checks",
            "IMA protection mode",
            "Measurement validation"
        ]
    },
    {
        "q": "What is kernel module signature?",
        "o": [
            "Cryptographic module verify",
            "No signature required",
            "Signature protection mode",
            "Module validation call"
        ]
    },
    {
        "q": "How does secure boot chain work?",
        "o": [
            "Verified boot from firmware",
            "No boot verification",
            "Boot protection mode",
            "Secure validation call"
        ]
    },
    {
        "q": "What is measured boot for kernel?",
        "o": [
            "TPM based measurement log",
            "No measurement done",
            "Boot protection mode",
            "Measured validation"
        ]
    },
    {
        "q": "How does dm-verity protect kernel?",
        "o": [
            "Block level integrity check",
            "No block integrity",
            "Verity protection mode",
            "Block validation call"
        ]
    },
    {
        "q": "What is AppArmor kernel protection?",
        "o": [
            "MAC based on paths",
            "No path restriction",
            "AppArmor prot mode",
            "Path validation call"
        ]
    },
    {
        "q": "How does SELinux protect kernel?",
        "o": [
            "MAC based on labels",
            "No label enforcement",
            "SELinux prot mode",
            "Label validation call"
        ]
    },
    {
        "q": "What is Yama security module?",
        "o": [
            "Ptrace scope restriction",
            "No ptrace limits",
            "Yama protection mode",
            "Ptrace validation"
        ]
    },
    {
        "q": "How does Landlock sandbox work?",
        "o": [
            "Userspace kernel sandboxing",
            "No sandbox applied",
            "Landlock prot mode",
            "Sandbox validation"
        ]
    },
    {
        "q": "What is LKRG module protection?",
        "o": [
            "Runtime integrity checking",
            "No runtime checks",
            "LKRG protection mode",
            "Integrity validation"
        ]
    },
    {
        "q": "How does kernel live patching work?",
        "o": [
            "Runtime code modification",
            "No live patching",
            "Patch protection mode",
            "Live validation call"
        ]
    },
    {
        "q": "What is kernel ASLR entropy?",
        "o": [
            "Bits of randomization",
            "No entropy measured",
            "ASLR protection mode",
            "Entropy validation"
        ]
    },
    {
        "q": "How does kernel oops protection work?",
        "o": [
            "Panic on oops for safety",
            "Continue after oops",
            "Oops protection mode",
            "Protection validation"
        ]
    },
    {
        "q": "What is kernel NX for data segments?",
        "o": [
            "Non executable data pages",
            "Execute all data ok",
            "NX protection mode",
            "Data validation call"
        ]
    },
    {
        "q": "How does hardened usercopy work?",
        "o": [
            "Validate copy boundaries",
            "No copy validation",
            "Copy protection mode",
            "Usercopy validation"
        ]
    },
    {
        "q": "What is STRUCTLEAK kernel option?",
        "o": [
            "Zero stack before use",
            "No zeroing applied",
            "Struct protection mode",
            "Leak validation call"
        ]
    },
    {
        "q": "How does kernel XOM work?",
        "o": [
            "Execute only memory pages",
            "Read and execute ok",
            "XOM protection mode",
            "Memory validation"
        ]
    },
    {
        "q": "What is kernel static key?",
        "o": [
            "Runtime code patching",
            "Compile time only",
            "Key protection mode",
            "Static validation call"
        ]
    },
    {
        "q": "How does retpoline mitigate spectre?",
        "o": [
            "Trap indirect calls in loop",
            "No speculation mitigation",
            "Retpoline prot mode",
            "Spectre validation"
        ]
    },
    {
        "q": "What is IBRS for spectre?",
        "o": [
            "Indirect branch speculation",
            "No branch restriction",
            "IBRS protection mode",
            "Speculation validation"
        ]
    },
    {
        "q": "How does IBPB help security?",
        "o": [
            "Barrier after context switch",
            "No barrier applied",
            "IBPB protection mode",
            "Barrier validation call"
        ]
    },
    {
        "q": "What is STIBP protection?",
        "o": [
            "Single thread BP restrict",
            "No thread restriction",
            "STIBP protection mode",
            "Thread validation call"
        ]
    },
    {
        "q": "How does SSBD mitigate SSB?",
        "o": [
            "Speculative store bypass disable",
            "No store mitigation",
            "SSBD protection mode",
            "Store validation call"
        ]
    },
    {
        "q": "What is L1TF kernel mitigation?",
        "o": [
            "L1 terminal fault flush",
            "No L1 mitigation",
            "L1TF protection mode",
            "Fault validation call"
        ]
    },
    {
        "q": "How does MDS mitigation work?",
        "o": [
            "CPU buffer clear on switch",
            "No buffer clearing",
            "MDS protection mode",
            "Buffer validation call"
        ]
    },
    {
        "q": "What is TAA vulnerability mitigation?",
        "o": [
            "TSX async abort protect",
            "No TSX mitigation",
            "TAA protection mode",
            "Abort validation call"
        ]
    },
    {
        "q": "How does SRBDS mitigation work?",
        "o": [
            "Random buffer sampling prot",
            "No sampling protection",
            "SRBDS protection mode",
            "Buffer validation call"
        ]
    },
    {
        "q": "What is MMIO exploit mitigation?",
        "o": [
            "MMIO stale data protection",
            "No MMIO protection",
            "MMIO protection mode",
            "Data validation call"
        ]
    },
    {
        "q": "How does kernel time protection work?",
        "o": [
            "Prevent timing side channels",
            "No timing protection",
            "Time protection mode",
            "Channel validation call"
        ]
    },
    {
        "q": "What is kernel address entropy level?",
        "o": [
            "Bits used for KASLR",
            "Fixed address always",
            "Entropy protection mode",
            "Address validation call"
        ]
    },
    {
        "q": "How does boot param hardening work?",
        "o": [
            "Restrict dangerous params",
            "Allow all parameters",
            "Param protection mode",
            "Boot validation call"
        ]
    },
    {
        "q": "What is kernel KCFI protection?",
        "o": [
            "Kernel control flow integrity",
            "Key call function init",
            "Kernel cache flush inst",
            "Known call format id"
        ]
    },
    {
        "q": "How does kernel UBSAN detect bugs?",
        "o": [
            "Undefined behavior sanitizer",
            "User buffer scan analysis",
            "Unsigned binary search algo",
            "Universal buffer security"
        ]
    }
]