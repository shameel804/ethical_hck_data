{
    "id": "advanced_exploitation",
    "topicId": "adv_exploit",
    "topicTitle": "Advanced Exploitation",
    "description": "Master advanced binary exploitation techniques including ROP chains, Heap Feng Shui, and Kernel exploitation.",
    "baseKP": 150,
    "slides": [
        {
            "id": "adv_exp_1",
            "type": "content",
            "title": "Welcome to Advanced Exploitation",
            "content": "# Advanced Exploitation ü•ã\n\nWhen basic stack overflows are blocked by modern mitigations (DEP, ASLR), we turn to advanced techniques.\n\n## What you'll learn:\n- **ROP Chains** - Bypassing NX/DEP\n- **Heap Exploitation** - Attacking dynamic memory\n- **Kernel Exploits** - Ring 0 execution\n- **Browser Exploitation** - Attacking JavaScript engines\n- **Mobile Exploitation** - Android/iOS specifics"
        },
        {
            "id": "adv_exp_2",
            "type": "content",
            "title": "Return Oriented Programming (ROP)",
            "content": "# ROP Chains üîó\n\n**Data Execution Prevention (DEP)** stops us from running code on the stack. **ROP** bypasses this by executing code strictly from existing, executable memory segments (like libc).\n\n## Gadgets\nA \"Gadget\" is a small sequence of instructions ending in `ret`. \nExample: `pop rdi; ret`\n\n## The Chain\nBy stacking return addresses on the stack, we control the CPU:\n1.  Return to Gadget 1 (`pop rdi; ret`)\n2.  Value for RDI (e.g., address of \"/bin/sh\")\n3.  Return to Gadget 2 (`call system`)\n\nWe build a custom program using only the ends of existing functions!"
        },
        {
            "id": "adv_exp_3",
            "type": "content",
            "title": "Finding Gadgets",
            "content": "# Finding ROP Gadgets üîé\n\nTools like `ROPGadget` or `ropper` scan binary files for useful instruction sequences.\n\n```bash\n$ ROPGadget --binary /lib/x86_64-linux-gnu/libc.so.6 | grep \"pop rdi\"\n0x000000000002155f : pop rdi ; ret\n```\n\nThe offset `0x2155f` is added to the leaked libc base address to calculate the runtime address of the gadget."
        },
        {
            "id": "adv_exp_4",
            "type": "content",
            "title": "Heap Exploitation Basics",
            "content": "# Heap Exploitation üì¶\n\nThe **Heap** is specialized dynamic memory. Unlike the linear Stack, it's organized into \"Chunks\".\n\n## Metadata Corruption\nEach chunk has a header (size, flags). If we overflow a chunk, we can overwrite the header of the *next* chunk.\n\n## Techniques\n- **Use-After-Free (UAF):** Accessing freed memory to hijack control flow.\n- **Double Free:** Freeing the same pointer twice, corrupting the free list logic.\n- **Heap Feng Shui:** Carefully allocating/freeing objects to arrange the heap in a predictable state for exploitation."
        },
        {
            "id": "adv_exp_5",
            "type": "content",
            "title": "Heap Simulation",
            "content": "# Heap Layout Demo üß±\n\nVisualizing how chunks are placed.\n\n<!-- FULL_CODE_START\nimport ctypes\n\n# Simulating a simple custom allocator scenario memory layout concept\nclass Chunk(ctypes.Structure):\n    _fields_ = [\n        (\"prev_size\", ctypes.c_uint64),\n        (\"size\", ctypes.c_uint64),\n        (\"data\", ctypes.c_char * 16)\n    ]\n\ndef simulate_heap_overflow():\n    # Allocate two sequential chunks\n    chunk_A = Chunk(0, 32, b\"AAAA\")\n    chunk_B = Chunk(32, 32, b\"BBBB\")\n    \n    print(\"--- Before Overflow ---\")\n    print(f\"Chunk B Size Header: {chunk_B.size}\")\n    print(f\"Chunk B Data: {chunk_B.data.decode()}\")\n    \n    # Simulate overflow: A writes passed its end into B's header\n    # In python ctypes, we have to be explicit, but in C gets() does this auto\n    print(\"\\n--- Overflows A -> B ---\")\n    # Writing into memory of B's size field via pointer arithmetic or bad index logic\n    # Doing direct modification for demo:\n    chunk_B.size = 99999\n    \n    print(f\"Chunk B Size Header (Corrupted): {chunk_B.size}\")\n    print(\"The allocator might now think Chunk B extends way further than it does!\")\n\nsimulate_heap_overflow()\nFULL_CODE_END -->"
        },
        {
            "id": "adv_exp_quiz_1",
            "type": "quiz",
            "title": "ROP Quiz",
            "content": "Check your ROP knowledge.",
            "quizQuestion": "Why is Return Oriented Programming (ROP) used instead of classic shellcode injection?",
            "quizOptions": [
                "It is faster to execute",
                "It bypasses Data Execution Prevention (DEP/NX)",
                "It works without internet",
                "It is easier to write"
            ],
            "correctOptionIndex": 1
        },
        {
            "id": "adv_exp_6",
            "type": "content",
            "title": "Kernel Exploitation",
            "content": "# Kernel Exploitation üêß\n\nThe Kernel (Ring 0) controls everything. Exploit a kernel driver, and you own the entire system (Root/System authority).\n\n## Attack Surface\n- **Syscalls:** Malformed arguments to system calls.\n- **Drivers:** 3rd party drivers often have fewer security checks than the core kernel.\n\n## Payloads\nInstead of `execl(\"/bin/sh\")`, kernel shellcode usually executes `commit_creds(prepare_kernel_cred(0))` to give the current process root permissions, then returns to user-land safely."
        },
        {
            "id": "adv_exp_7",
            "type": "content",
            "title": "Kernel Null Pointer Dereference",
            "content": "# Null Pointer Dereference üö´\n\nIf the kernel tries to read/write to address 0x0 and the attacker can map memory at 0x0 (which classic mmap allowed), they can control what the kernel sees.\n\nModern OSes set `mmap_min_addr` to prevent users from mapping the zero page, mitigating this class of bugs effectively in user-land interactions."
        },
        {
            "id": "adv_exp_8",
            "type": "content",
            "title": "Browser Exploitation",
            "content": "# Browser Exploitation üåç\n\nModern browsers are extremely complex, with JIT (Just-In-Time) compilers for JavaScript being a prime target.\n\n## JIT Bugs\nJIT optimization phases can remove vital bounds checks if it incorrectly assumes a variable's type or range. Attackers trigger these optimizations to achieve OOB (Out of Bounds) read/write in the JS array, leading to arbitrary native code execution."
        },
        {
            "id": "adv_exp_9",
            "type": "content",
            "title": "Browser Heap Spray",
            "content": "# Heap Spraying üí¶\n\nA technique to facilitate exploitation by filling the memory with a specific pattern (usually NOP sleds + shellcode).\n\nIn browsers, you create millions of strings containing your payload. When the bug triggers a jump to a random or approximate address, chances are it hits your \"spray\" area, executing the payload.\n\nModern 64-bit address spaces make spraying much harder (too much RAM needed to fill it)."
        },
        {
            "id": "adv_exp_10",
            "type": "content",
            "title": "Mobile Exploitation (Android)",
            "content": "# Android Exploitation ü§ñ\n\nAndroid is Linux-based but heavily sandboxed.\n\n## Components\n- **Binder:** IPC mechanism. A historically rich attack surface.\n- **MediaServer:** Processes video/audio. Stagefright was a famous set of bugs here.\n\n## Rooting\n\"Rooting\" an Android phone is essentially running a local privilege escalation exploit against the Android Kernel to just `su`."
        },
        {
            "id": "adv_exp_11",
            "type": "content",
            "title": "iOS Exploitation",
            "content": "# iOS Exploitation üçè\n\niOS is known for its \"Walled Garden\" and strict code signing.\n\n## Jailbreaking Chains\nTo Jailbreak iOS, you typically need a chain:\n1.  **Webkit Exploit:** Gain userland code execution via Safari.\n2.  **Sandbox Escape:** Break out of the browser sandbox to access OS resources.\n3.  **Kernel Exploit:** Gain kernel privileges to disable code signing (AMFI) and remount root as RW."
        },
        {
            "id": "adv_exp_12",
            "type": "content",
            "title": "Race Conditions",
            "content": "# Race Conditions üèÅ\n\nOccur when the system's behavior depends on the timing of uncontrollable events.\n\n## TOCTOU (Time of Check to Time of Use)\n1.  System checks if User has permission to file X (Check).\n2.  Attacker quickly swaps file X with a symlink to `/etc/passwd`.\n3.  System writes to file (Use).\n\nIf step 2 happens exactly between 1 and 3, security is bypassed."
        },
        {
            "id": "adv_exp_13",
            "type": "content",
            "title": "Race Condition Simulation",
            "content": "# Threading Race Demo üèÉ\n\nTwo threads trying to modify a shared resource.\n\n<!-- FULL_CODE_START\nimport threading\nimport time\n\naccount_balance = 100\n\ndef withdraw(amount):\n    global account_balance\n    # Vulnerable logic: Check then Modify not atomic\n    print(f\"Checking balance for withdrawal of {amount}...\")\n    if account_balance >= amount:\n        # Simulate processing delay to widen the race window\n        time.sleep(0.1)\n        account_balance -= amount\n        print(f\"Withdrawal success! New Balance: {account_balance}\")\n    else:\n        print(\"Insufficient funds!\")\n\nprint(f\"Initial Balance: {account_balance}\")\n\n# Launch two threads trying to withdraw 100 each simultaneously\nt1 = threading.Thread(target=withdraw, args=(100,))\nt2 = threading.Thread(target=withdraw, args=(100,))\n\nt1.start()\nt2.start()\n\nt1.join()\nt2.join()\n\nprint(f\"Final Balance: {account_balance}\")\nif account_balance < 0:\n    print(\"RACE CONDITION SUCCEEDED: We spent double the money!\")\nFULL_CODE_END -->"
        },
        {
            "id": "adv_exp_14",
            "type": "content",
            "title": "Format String (Advanced)",
            "content": "# Format String Writes %n ‚úçÔ∏è\n\nWe saw `%x` for reading. `%n` is for writing.\n\n`%n` writes the *count of characters printed so far* to the integer pointer argument.\n\nBy carefully padding input (`%100x%n`), we can write specific values (like 100) to specific addresses. This allows overwriting Return Addresses or GOT (Global Offset Table) entries without buffer overflows."
        },
        {
            "id": "adv_exp_15",
            "type": "content",
            "title": "Side Channel Attacks",
            "content": "# Side Channels üëª\n\nAttacking the implementation, not the algorithm.\n\n## Spectre & Meltdown\nExploiting **Speculative Execution** in CPUs. The CPU guesses which branch to take for speed. If it guesses wrong, it rolls back changes, but *cache state* remains changed. Attackers measure access times (Timing Attack) to read secret memory leaked into the cache."
        },
        {
            "id": "adv_exp_16",
            "type": "content",
            "title": "Summary",
            "content": "# Advanced Exploitation Summary üß†\n\nThis module covered the bleeding edge of hacking.\n\n## Recap\n- **ROP** uses existing code to bypass DEP.\n- **Heap Exploits** target the dynamic allocator metadata.\n- **Kernel Exploits** provide total system control.\n- **Timing Attacks** leak data without direct access.\n\nThese techniques require deep understanding of OS internals and architecture (x86/ARM)."
        },
        {
            "id": "adv_exp_quiz_2",
            "type": "quiz",
            "title": "Concept Check",
            "content": "Final check.",
            "quizQuestion": "Which type of vulnerability involves swapping a file between the 'check' and 'use' phases?",
            "quizOptions": [
                "Buffer Overflow",
                "Use After Free",
                "TOCTOU (Race Condition)",
                "ROP Chain"
            ],
            "correctOptionIndex": 2
        }
    ]
}