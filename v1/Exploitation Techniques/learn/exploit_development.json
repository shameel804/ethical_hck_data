{
    "id": "exploit_development",
    "topicId": "exploit_dev_basics",
    "topicTitle": "Exploit Development Basics",
    "description": "Master the fundamentals of software exploitation, including buffer overflows, format strings, and shellcode writing.",
    "baseKP": 100,
    "slides": [
        {
            "id": "exp_dev_1",
            "type": "content",
            "title": "Welcome to Exploit Development",
            "content": "# Exploit Development Basics üîì\n\nWelcome to the world of low-level exploitation! In this module, you will learn how vulnerabilities in software can be leveraged to execute arbitrary code.\n\n## What you'll learn:\n- **Buffer Overflows** - Smashing the stack for fun and profit\n- **Format String Bugs** - Reading and writing memory arbitrarily\n- **Integer Overflows** - When math goes wrong\n- **Memory Corruption** - Understanding heap and stack issues\n- **Shellcode** - Writing machine code payloads\n\n> ‚ö†Ô∏è **Warning:** The techniques taught here are powerful. Always perform ethical hacking in authorized environments only!"
        },
        {
            "id": "exp_dev_2",
            "type": "content",
            "title": "Introduction to Buffer Overflows",
            "content": "# Buffer Overflows üí•\n\nA **Buffer Overflow** occurs when a program writes more data to a buffer (a temporary storage area) than it can hold. The excess data overflows into adjacent memory locations.\n\n## Why is this dangerous?\n\nBy overwriting adjacent memory, an attacker can:\n- **Crash the program** (Denial of Service)\n- **Corrupt data**\n- **Overwrite the Return Address** (EIP/RIP) to redirect execution flow to malicious code (Shellcode)\n\n## The Stack Layout\n\n```text\n[ Buffer ] [ SFP ] [ Return Address ] [ Arguments ]\n```\n\nIf we fill the Buffer and keep writing, we hit the Saved Frame Pointer (SFP) and then the **Return Address**. Controlling the Return Address means controlling the CPU!"
        },
        {
            "id": "exp_dev_3",
            "type": "content",
            "title": "Vulnerable C Code Example",
            "content": "# A Vulnerable Function üìù\n\nConsider this C code using the unsafe `strcpy` function.\n\n```c\n#include <string.h>\n\nvoid vulnerable_function(char *str) {\n    char buffer[10];\n    // strcpy does not check bounds!\n    strcpy(buffer, str);\n}\n\nint main(int argc, char **argv) {\n    if (argc > 1)\n        vulnerable_function(argv[1]);\n    return 0;\n}\n```\n\n<!-- FULL_CODE_START\n#include <stdio.h>\n#include <string.h>\n\nvoid vulnerable_function(char *str) {\n    char buffer[10];\n    printf(\"Buffer is at: %p\\n\", (void*)buffer);\n    // Adding a check to prevent actual crash in this demo environment, \n    // but normally strcpy(buffer, str) would be the vulnerability.\n    if (strlen(str) >= 10) {\n        printf(\"Error: Input too long! This would cause a buffer overflow.\\n\");\n    } else {\n        strcpy(buffer, str);\n        printf(\"Copied: %s\\n\", buffer);\n    }\n}\n\nint main() {\n    char *safe_input = \"Hello\";\n    char *malicious_input = \"AAAAAAAAAAAABBBBCCCC\";\n\n    printf(\"Running with safe input...\\n\");\n    vulnerable_function(safe_input);\n\n    printf(\"\\nRunning with malicious input...\\n\");\n    vulnerable_function(malicious_input);\n\n    return 0;\n}\nFULL_CODE_END -->\n\nIf `str` is longer than 10 bytes, `strcpy` will keep writing past `buffer`, potentially overwriting the return address."
        },
        {
            "id": "exp_dev_quiz_1",
            "type": "quiz",
            "title": "Buffer Overflow Check",
            "content": "Test your knowledge on stack overflows.",
            "quizQuestion": "In a standard stack buffer overflow, what is the critical register values attacker aims to overwrite to control program execution?",
            "quizOptions": [
                "EAX (Accumulator)",
                "EIP/RIP (Instruction Pointer)",
                "ESP (Stack Pointer)",
                "EBP (Base Pointer)"
            ],
            "correctOptionIndex": 1
        },
        {
            "id": "exp_dev_4",
            "type": "content",
            "title": "Format String Vulnerabilities",
            "content": "# Format String Bugs üî£\n\nFormat string vulnerabilities occur when user input is passed as the format string parameter to functions like `printf`.\n\n## The Flaw\n\n**Secure:** `printf(\"%s\", user_input);`\n**Vulnerable:** `printf(user_input);`\n\nIf a user enters format specifiers like `%x` or `%n`, they can read or write memory.\n\n## Capabilities\n- **Memory Leak:** `%x` prints stack values. `%s` prints memory at an address.\n- **Arbitrary Write:** `%n` writes the number of bytes printed so far to a memory address."
        },
        {
            "id": "exp_dev_5",
            "type": "content",
            "title": "Format String Demo",
            "content": "# Exploiting Printf üïµÔ∏è\n\nLet's see how reading stack data works.\n\n```c\n// user_input = \"%x %x %x %x\"\nprintf(user_input);\n```\n\n<!-- FULL_CODE_START\n#include <stdio.h>\n\nint main() {\n    int secret = 0x1337;\n    // In a real scenario, this string comes from user input\n    char *user_input = \"Stack values: %x %x %x %x %x\";\n    \n    printf(\"Secret is stored at: %p\\n\", (void*)&secret);\n    printf(\"Executing: printf(\\\"%s\\\")\\n\", user_input);\n    \n    // Passing user_input directly as the format string\n    printf(user_input);\n    printf(\"\\n\");\n    \n    return 0;\n}\nFULL_CODE_END -->\n\nThe output will show values from the stack, potentially leaking sensitive information like canary values or passwords."
        },
        {
            "id": "exp_dev_6",
            "type": "content",
            "title": "Integer Overflows",
            "content": "# Integer Overflows üî¢\n\nAn **Integer Overflow** occurs when an arithmetic operation attempts to create a numeric value that is outsides of the range that can be represented with a given number of bits.\n\n## Wraparound Behavior\n\nFor a standard 32-bit `unsigned int`:\n- Max value: 4,294,967,295\n- Max value + 1 = 0\n\n## Security Implication\n\nThis often leads to buffer overflows. Imagine a check:\n```c\nif (size + header_size > buffer_max) return error;\nallocate(size + header_size);\n```\nIf `size` is huge, `size + header_size` might wrap around to a small number, passing the check, but then `allocate` creates a tiny buffer which we then copy huge data into."
        },
        {
            "id": "exp_dev_7",
            "type": "content",
            "title": "Integer Overflow Example",
            "content": "# Integer Overflow in Action üé¨\n\nCalculations on user-supplied types must be checked carefully.\n\n<!-- FULL_CODE_START\n#include <stdio.h>\n#include <limits.h>\n\nint main() {\n    unsigned int max = UINT_MAX;\n    unsigned int result;\n\n    printf(\"Max unsigned int: %u\\n\", max);\n    \n    // Overflow\n    result = max + 1;\n    printf(\"Max + 1 = %u (Wraparound!)\\n\", result);\n\n    // Dangerous usage scenario logic\n    unsigned int item_count = 1073741824; // Large number\n    unsigned int item_size = 4;\n    unsigned int total_size = item_count * item_size;\n    \n    printf(\"\\nIf we need %u bytes for %u items...\\n\", total_size, item_count);\n    \n    // Check if we accidentally wrapped around to 0\n    if (total_size == 0) {\n         printf(\"CRITICAL: Loop wrapped to 0! Allocation would be too small.\\n\");\n    }\n\n    return 0;\n}\nFULL_CODE_END -->\n\nIf this `total_size` was used for `malloc()`, it would allocate 0 bytes, but the subsequent copy loop would try to copy gigabytes of data."
        },
        {
            "id": "exp_dev_quiz_2",
            "type": "quiz",
            "title": "Integer Overflow Quiz",
            "content": "Check your understanding of integer limits.",
            "quizQuestion": "If an 8-bit unsigned integer holds the value 255 and you add 1 to it, what is the result?",
            "quizOptions": [
                "256",
                "0",
                "-1",
                "Error/Exception"
            ],
            "correctOptionIndex": 1
        },
        {
            "id": "exp_dev_8",
            "type": "content",
            "title": "Memory Corruption",
            "content": "# Memory Corruption üß†\n\nMemory corruption refers to modifying memory contents in a way that violates specifications or safety.\n\n## Types\n- **Stack Corruption:** Overwriting return addresses, local variables.\n- **Heap Corruption:** Manipulating dynamic memory chunks (metadata) allocated via `malloc`/`new`. techniques include **Use-After-Free** and **Double Free**.\n\n## Consequence\nAttackers can manipulate the layout of objects in the heap to overwrite function pointers (e.g., in C++ vtables) to hijack control flow."
        },
        {
            "id": "exp_dev_9",
            "type": "content",
            "title": "Use-After-Free (UAF)",
            "content": "# Use-After-Free üëª\n\nA UAF vulnerability occurs when a program continues to use a pointer after the memory it points to has been freed.\n\n## The Scenario\n1. `ptr = malloc(32);`\n2. `free(ptr);` // Memory is marked available\n3. `ptr2 = malloc(32);` // Allocator might reuse the same slot!\n4. `*ptr = data;` // Original pointer writes to memory now owned by ptr2!\n\nThis can lead to data corruption or code execution if the newly allocated object contains function pointers."
        },
        {
            "id": "exp_dev_10",
            "type": "content",
            "title": "Shellcode Development",
            "content": "# Shellcode Development üêö\n\n**Shellcode** is a small piece of code used as the payload in the exploitation of a software vulnerability. It gets its name from typically starting a command shell.\n\n## Characteristics\n- **Position Independent:** Must run from any memory address.\n- **No Null Bytes:** Standard string functions (`strcpy`) stop at null bytes (`\\x00`), so shellcode often must avoid them.\n- **Direct Syscalls:** Uses kernel system calls to perform actions (execve, exit, etc.)."
        },
        {
            "id": "exp_dev_11",
            "type": "content",
            "title": "Anatomy of Shellcode",
            "content": "# Shellcode Assembly (x86) üß©\n\nHere is how a simple `execve(\"/bin//sh\", 0, 0)` might look in assembly.\n\n```nasm\nxor eax, eax    ; Zero out EAX (avoid null bytes)\npush eax        ; Push null terminator\npush 0x68732f2f ; Push \"//sh\"\npush 0x6e69622f ; Push \"/bin\"\nmov ebx, esp    ; EBX points to string\nmov ecx, eax    ; ECX = 0 (argv)\nmov edx, eax    ; EDX = 0 (envp)\nmov al, 0xb     ; Syscall 11 (execve)\nint 0x80        ; Trigger syscall\n```\n\nThis code sets up the stack and registers to call the kernel to spawn a shell."
        },
        {
            "id": "exp_dev_12",
            "type": "content",
            "title": "Generating Shellcode with Python",
            "content": "# Generating Payloads üêç\n\nWe often use Python to generate the raw byte string for exploits.\n\n<!-- FULL_CODE_START\n# Simple NOP Sled + Shellcode simulation\n\ndef generate_payload():\n    # NOP Sled (No Operation)\n    # 0x90 is the opcode for NOP on x86\n    nop_sled = \"\\x90\" * 20\n    \n    # Dummy Shellcode (Not real, just placeholders)\n    # In reality this would be the opcodes for the shellcode\n    shellcode = \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"\n    \n    # Return Address\n    # We overwritting EIP with an address pointing to our NOP sled\n    # Little Endian format: 0xbffff3a0 -> \\xa0\\xf3\\xff\\xbf\n    ret_addr = \"\\xa0\\xf3\\xff\\xbf\" * 4\n    \n    payload = nop_sled + shellcode + ret_addr\n    return payload\n\np = generate_payload()\n\n# Helper to print distinct hex bytes\ndef print_hex(data):\n    print(''.join(f'\\\\x{ord(c):02x}' for c in data))\n\nprint(\"Exploit Payload Structure:\")\nprint(\"--------------------------\")\nprint(f\"NOP Sled (20 bytes): \\n{'\\\\x90' * 20}\")\nprint(\"\\nShellcode:\\n...[binary code]...\")\nprint(\"\\nReturn Address overwrite (repeated):\\n...\\\\xa0\\\\xf3\\\\xff\\\\xbf...\")\nFULL_CODE_END -->"
        },
        {
            "id": "exp_dev_13",
            "type": "content",
            "title": "Mitigations",
            "content": "# Exploit Mitigations üõ°Ô∏è\n\nModern OSes have defenses against these attacks.\n\n## Common Protections\n- **ASLR (Address Space Layout Randomization):** Randomizes memory locations of stack, heap, and libraries so attackers can't predict addresses.\n- **DEP / NX (Data Execution Prevention):** Marks stack and heap as non-executable. Shellcode on the stack won't run.\n- **Stack Canaries:** Places a random value before the Return Address. If it changes (overflow), the program aborts.\n- **PIE (Position Independent Executable):** Randomizes the code segment itself."
        },
        {
            "id": "exp_dev_14",
            "type": "content",
            "title": "Bypassing Mitigations",
            "content": "# Bypassing Defenses ü•∑\n\nHackers rely on advanced techniques to bypass mitigations.\n\n- **ROP (Return Oriented Programming):** Used often to bypass DEP. Instead of running shellcode, attackers chain together existing small chunks of code (\"gadgets\") already present in executable memory (like libc) to perform actions.\n- **Info Leaks:** Used to bypass ASLR. If you can read a memory pointer, you can calculate the randomization offset.\n- **Brute Force:** Sometimes viable against weak ASLR (e.g., on 32-bit systems)."
        },
        {
            "id": "exp_dev_15",
            "type": "content",
            "title": "Fuzzing for Vulnerabilities",
            "content": "# Fuzzing üå™Ô∏è\n\nHow do we find these bugs?\n\n**Fuzzing** is an automated testing technique that involves providing invalid, unexpected, or random data as inputs to a computer program.\n\n## Types\n- **Mutation Based:** Modifies existing valid inputs slightly (bit flipping).\n- **Generation Based:** Generates inputs from scratch based on a format specification.\n\nPopular tools: AFL (American Fuzzy Lop), libFuzzer, SPIKE."
        },
        {
            "id": "exp_dev_16",
            "type": "content",
            "title": "Simple Fuzzer Example",
            "content": "# Basic Fuzzer Logic üêç\n\nA simple script to send random data to a target.\n\n<!-- FULL_CODE_START\nimport random\nimport string\n\ndef fuzz_string(max_length=100):\n    length = random.randint(1, max_length)\n    # Generate random string including printable and non-printable\n    chars = string.printable \n    return ''.join(random.choice(chars) for _ in range(length))\n\nprint(\"Fuzzer Mockup Running...\\n\")\n\nfor i in range(5):\n    payload = fuzz_string(50)\n    # In a real fuzzer, we would send this 'payload' to a target binary/service\n    # and monitor for crashes (SIGSEGV)\n    print(f\"Test Case #{i+1}: Length {len(payload)}\")\n    print(f\"Payload: {payload[0:20]}... (truncated)\")\n    print(\"Status: No Crash\\n\")\n\nprint(\"Simulation Complete.\")\nFULL_CODE_END -->"
        },
        {
            "id": "exp_dev_17",
            "type": "content",
            "title": "Summary",
            "content": "# Module Summary üéì\n\nYou've explored the foundations of binary exploitation.\n\n## Key Takeaways\n- **Buffer Overflows** allow overtaking execution flow by corrupting the stack.\n- **Format Strings** can read/write arbitrary memory.\n- **Integer Overflows** can lead to logic errors and heap overflows.\n- **Shellcode** is the payload executed after exploitation.\n- **Mitigations** like ASLR and DEP make exploitation harder, requiring techniques like **ROP**.\n\nAlways use these skills responsibly to secure systems!"
        }
    ]
}