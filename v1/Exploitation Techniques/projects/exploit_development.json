[
    {
        "title": "Buffer Overflows",
        "ques": "A **Buffer Overflow** is the most classic memory corruption vulnerability. Explain how copying the string `\"AAAAAAAAAAAA\"` into a buffer of size 8 can lead to code execution.",
        "answer": {
            "type": "text",
            "content": "The buffer only holds 8 'A's. The remaining 4 'A's spill over into adjacent memory.\n\nThe danger is that the **Instruction Pointer (EIP/RIP)**—which tells the CPU what code to execute next—is often stored right next to local buffers on the stack. If we overwrite the EIP with a specific address (instead of 'A's), we can redirect the CPU to execute our own malicious code (shellcode)."
        },
        "explanation": "You are literally rewriting the program's execution flow by writing too much data."
    },
    {
        "title": "Format String Vulnerabilities",
        "ques": "What happens if a C programmer uses `printf(userInput)` instead of `printf(\"%s\", userInput)`? What can an attacker inject to read memory?",
        "answer": {
            "type": "text",
            "content": "If the attacker inputs format specifiers like `%x` (hex) or `%s` (string), `printf` interprets them as commands to read from the stack.\n\n**Exploit:** Sending `%x %x %x %x` will print raw values from the program's memory stack, leaking addresses or sensitive data."
        },
        "explanation": "Never trust user input to be part of the format string."
    },
    {
        "title": "Integer Overflows",
        "ques": "An **Integer Overflow** occurs when an arithmetic operation attempts to create a numeric value that is too large to be represented within the available storage space. How can this lead to a buffer overflow?",
        "answer": {
            "type": "text",
            "content": "Imagine asking for a buffer of size `len + 5`. If `len` is the maximum integer value, adding 5 wraps the number around to a small positive number (e.g., 4).\n\nThe program allocates 4 bytes of memory, but then tries to copy the original massive amount of data into it. Boom -> Buffer Overflow."
        },
        "explanation": "It's a math error that triggers a memory error."
    },
    {
        "title": "Shellcode Development",
        "ques": "What is **Shellcode**? Why must it be 'Position Independent' and effectively null-free (no `\\x00` bytes)?",
        "answer": {
            "type": "text",
            "content": "**Shellcode:** A small piece of code used as the payload in the exploitation of a software vulnerability (usually to spawn a command shell).\n\n1.  **Position Independent:** We don't know exactly where in memory our code will land, so it cannot rely on hardcoded memory addresses.\n2.  **Null-Free:** Functions like `strcpy` stop copying when they hit a null byte (`\\x00`). If our code has one, the copy stops early, and the exploit fails."
        },
        "explanation": "Writing good shellcode is an art form in Assembly."
    },
    {
        "title": "Memory Corruption: Heap vs. Stack",
        "ques": "Distinguish between **Stack-based** and **Heap-based** overflows.",
        "answer": {
            "type": "text",
            "content": "*   **Stack:** LIFO (Last In, First Out) structure used for static variables and function calls. Easiest to exploit (overwrite Return Address).\n*   **Heap:** Dynamic memory used for variables created at runtime (e.g., `malloc()`). Harder to exploit; typically involves corrupting metadata chunks to manipulate the memory allocator."
        },
        "explanation": "The stack is predictable; the heap is messy."
    }
]