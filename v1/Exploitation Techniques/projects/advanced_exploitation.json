[
    {
        "title": "ROP Chains (Return-Oriented Programming)",
        "ques": "Modern OS protections like **DEP** (Data Execution Prevention) stop attackers from executing shellcode on the stack. How do **ROP Chains** bypass this?",
        "answer": {
            "type": "text",
            "content": "Instead of writing new code, **ROP** reuses small chunks of existing, executable code (called **Gadgets**) already present in the program's memory (like `libc`).\n\n**Mechanism:** It chains these gadgets together `ret` (return) by `ret` to build a functional program out of the existing scraps. Since the code is already marked executable (it's part of the OS), DEP doesn't block it."
        },
        "explanation": "It's like writing a ransom note by cutting letters out of a magazine."
    },
    {
        "title": "Browser Exploitation: Use-After-Free",
        "ques": "A **Use-After-Free (UAF)** vulnerability is common in browsers. Describe the basic concept.",
        "answer": {
            "type": "text",
            "content": "1.  **Free:** The program frees a chunk of memory (e.g., an object is deleted).\n2.  **Dangling Pointer:** The program keeps a pointer to that freed memory location.\n3.  **Use:** The program tries to use that pointer again.\n\n**Exploit:** If an attacker can force the browser to allocate their own malicious object in that specific freed spot *before* step 3, the browser will execute the attacker's data thinking it is the original object."
        },
        "explanation": "It's retrieving a package from a locker that you thought was yours, but someone swapped the contents."
    },
    {
        "title": "Heap Spraying",
        "ques": "How does **Heap Spraying** assist in exploiting memory corruption vulnerabilities?",
        "answer": {
            "type": "text",
            "content": "**Heap Spraying** involves filling the memory (Heap) with copy after copy of the exploit payload (usually NOP sleds + Shellcode).\n\n**Goal:** To increase the probability that if the program jumps to a random location in the heap (due to a crash or bug), it will land on the malicious code. It creates a 'bigger target'."
        },
        "explanation": "It changes a needle in a haystack into a haystack made of needles."
    },
    {
        "title": "Kernel Exploits",
        "ques": "Why is a **Kernel Exploit** (Ring 0) significantly more dangerous than a User Mode (Ring 3) exploit?",
        "answer": {
            "type": "text",
            "content": "**Ring 0** is the highest privilege level. If you exploit the Kernel:\n1.  **Total Control:** You bypass all OS security controls (ACLs, AV, Anticheat).\n2.  **Stability Risk:** A bad kernel exploit crashes the entire system (Blue Screen of Death), not just one app."
        },
        "explanation": "God Mode for hackers."
    },
    {
        "title": "ASLR (Address Space Layout Randomization)",
        "ques": "**ASLR** is a defense that randomizes memory locations. How does it make exploitation harder?",
        "answer": {
            "type": "text",
            "content": "**Without ASLR:** System libraries (like `system()`) always load at the same address (e.g., `0x77e62`). Attackers can hardcode this address.\n**With ASLR:** The OS randomly shifts these locations every time the computer boots.\n\n**Impact:** The attacker no longer knows where the vulnerable functions are. They must find an 'Information Leak' first to calculate the offsets."
        },
        "explanation": "It turns a static map into a shifting maze."
    }
]